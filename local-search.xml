<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从技术思维到商业逻辑——品读《你凭什么做好互联网》</title>
    <link href="/2021/03/17/%E4%BD%A0%E5%87%AD%E4%BB%80%E4%B9%88%E5%81%9A%E5%A5%BD%E4%BA%92%E8%81%94%E7%BD%91%EF%BC%9F/"/>
    <url>/2021/03/17/%E4%BD%A0%E5%87%AD%E4%BB%80%E4%B9%88%E5%81%9A%E5%A5%BD%E4%BA%92%E8%81%94%E7%BD%91%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>因为平时学习时间紧迫，加上工作的任务比较繁重，所以有一段时间没有更新博客了。近期读了一本很火的书《你凭什么做好互联网》，让我颇有体会。</p><p>这本书是曹政在对于自己从业20多年互联网的经验总结，通过严谨的逻辑思维分析个人和企业在互联网发展的错误思想及做法，并给出了指导建议。</p></blockquote><p>当下互联网之势千变万化，如何在瞬息之间把握住趋势，乘势而为，成就一帆事业，或许是每一个程序员的梦想吧。</p><h2 id="取舍之道"><a href="#取舍之道" class="headerlink" title="取舍之道"></a>取舍之道</h2><p>在该书中有一篇“取舍之道”，我觉得对于做产品的人能受到很多启发，包括我们技术人员。</p><p>因为产品经理会面对来自各界的需求，有老板的需求，有运营同事的需求，有用户反馈的需求，还有自己突然灵机一动一闪而过的需求。</p><p>。。。。这么多需求到底要不要做？ 要怎么做？ 优先级是什么？怎样判断效果？</p><p>当然我们会因为很多干扰的因素，比如老板的命令，数据的错误解读，运营同事的催促而下很多决定。我们往往会忘记最基本的诉求：能否满足用户的核心诉求。</p><blockquote><p>不要试图讨好所有人，要明确核心用户群体的诉求，有所取舍，让一部分人惊喜，另一部分让人离开，比平庸的四处讨巧的产品可能更好。</p></blockquote><p>这样一句很简单的话，看过之后，你可能像我一样，会立马反应，这话我知道啊。但是我们很多时候都会发现，做着做着就忘了。</p><h2 id="信息不对称一直存在"><a href="#信息不对称一直存在" class="headerlink" title="信息不对称一直存在"></a>信息不对称一直存在</h2><p>说起互联网，可能很多人都觉得高大上，人工智能的兴起，大数据领域的应用，在这些庞大而复杂的信息下，我们却不知道其实互联网是一个巨大的谎言。信息是公开透明的，但很遗憾，却不是真实的。</p><p>就像我们在大海里钓鱼，大海会给我们提供很多鱼，但我们并不知道会钓到什么样的鱼。就像在庞大的信息海洋里，互联网能知道我们真正想获取的信息么？ 稍不留神就被各种营销达人，无良商家左右。</p><p>因此，我们一定要提升自己对信息获取和甄别的能力，避免被带偏了。</p><p>根据互联网”免费“理论，所有免费的要么是第三方转移，要么是交叉补贴或者基础免费，高级版收费模式。你如果发现自己什么没有付出，所谓的高质量从何而来。</p><p>所以，我想告诉大家，不要总是想着白嫖，通过付费来过滤掉干扰信息。这样作者有了一定收入就能安心创作了。</p><p><strong>所以我这里才强调付费的东西才是最好的，所以大家觉得满意的话，不妨扫描一下下方二维码。支持一下老弟。</strong></p><h2 id="信用与操守相伴一生"><a href="#信用与操守相伴一生" class="headerlink" title="信用与操守相伴一生"></a>信用与操守相伴一生</h2><p>这种大道理原则上大家都知道，为什么还要在这儿强调一遍呢？</p><p>信用的价值就是你公司或个人的品牌，如果你不小心丢失了，后期找回来成本非常高，必须要谨慎对待。</p><p>尤其是那种轻易承诺了无法兑现的事情，会失信于人，以后将会难以合作。</p><p>作者提到在对产品和人背书要做好背景调查，即使是朋友也要把握好原则。</p><p>这一点看起来简单，但是很多时候我们做起来不注意就会把自己坑进去。</p><p>记得某司高管曾经在微博上推荐过一个产品，然后这个产品跑路了，最后每次公司在V2ex去做推广都会被指出来说不靠谱。</p><h2 id="分享即学习"><a href="#分享即学习" class="headerlink" title="分享即学习"></a>分享即学习</h2><p>我这个人就特别喜欢分享，我觉得分享能力也是一种比较正要的能力，也是技术人员比较容易忽视的能力。</p><p>教是最好的学，你如果说不清楚这个东西，十有八九自己也没有学懂。</p><p>很多同学觉得我很厉害，但其实并没有，我只是喜欢把自己学到的东西总结一下分享出来，或者讲给别人。</p><h2 id="保持对信息的敏锐，好奇心"><a href="#保持对信息的敏锐，好奇心" class="headerlink" title="保持对信息的敏锐，好奇心"></a>保持对信息的敏锐，好奇心</h2><p>说到敏感度和好奇心，我就想到自己刚上大学的时候，逛各种IT社区论坛的时候，因为刚入行看到论坛里面的帖子，几乎都看不太懂，为了能够融入进去和大家交流，所以就挨个挨个的Google，百度。</p><p>所以久而久之，论坛社区里面的技术关键词，都能看明白，都清楚讲的什么了。后面自己在社区前辈指导下，慢慢琢磨出一个开发学习方向，然后做出一个完整的项目，在大二的时候就拿到一个Java开发的实习offer，开始从此就踏上了一个程序员这个的不归路。</p><p>上面谈的更多的是想说明对信息的敏锐好奇可以让我们保持进步，而不是一直在原地踏步。</p><p>有敏感度你就会不断的提出问题，然后寻求答案</p><h2 id="机会来自担当"><a href="#机会来自担当" class="headerlink" title="机会来自担当"></a>机会来自担当</h2><p>作者说到「机会来自担当」主动担当任务，虽然可能会因为准备不足，面临各种各样问题，但是也正是这些问题能够激发锻炼我们，从而不断提升个人能力。</p><p>其实自己工作中也是那种「爱搞事，不怕死」的，只要有机会就会争取，不管碰到啥任务，反正就是干，充其量多加几个晚班，要相信方法总比问题多的。</p><p>整本书不仅有各种互联网的案例故事研究，还有各种产品设计思路，方法论，作者信手拈来，被称为互联网的百晓生是有道理的，强烈推荐大家去阅读。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper入门到精通</title>
    <link href="/2021/02/13/Zookeeper%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    <url>/2021/02/13/Zookeeper%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是Zookeeper"><a href="#什么是Zookeeper" class="headerlink" title="什么是Zookeeper"></a>什么是Zookeeper</h2><p>在分布式场景下我们经常会接触到zookeeper，比如使用zookeeper生成分布式id、实现分布式锁、实现服务治理…..</p><p>我们先来看一下对zookeeper比较官方的定义。</p><blockquote><p>zooKeeper是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一 个高性能、高可用，且具有严格顺序访问控制能力的分布式协调存储服务。</p></blockquote><p>其主要功能：</p><ul><li>维护配置信息 </li><li>分布式锁服务 </li><li>集群管理 </li><li>生成分布式唯一ID</li></ul><h3 id="zk的设计目标"><a href="#zk的设计目标" class="headerlink" title="zk的设计目标"></a>zk的设计目标</h3><p> 1.高性能</p><blockquote><p>zooKeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，尤 其适用于以读为主的应用场景</p></blockquote><p>2.高可用</p><blockquote><p>zooKeeper一般以集群的方式对外提供服务，一般3 ~ 5台机器就可以组成一个可用 的Zookeeper集群了，每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都相 互保持着通信。只要集群中超过一半的机器都能够正常工作，那么整个集群就能够正常对外服 务</p></blockquote><p>3.严格顺序访问</p><blockquote><p>对于来自客户端的每个更新请求，ZooKeeper都会分配一个全局唯一的递增编号， 这个编号反映了所有事务操作的先后顺序</p></blockquote><h3 id="zk的数据模型"><a href="#zk的数据模型" class="headerlink" title="zk的数据模型"></a>zk的数据模型</h3><p>zookeeper的数据节点可以视为树状结构（或者目录），树中的各节点被称为 znode（即zookeeper node），一个znode可以有多个子节点。zookeeper节点在结构 上表现为树状；使用路径path来定位某个znode</p><p>一个znode大体上分为3各部分：</p><ul><li>节点的数据：即znode data(节点path, 节点data)的关系就像是java map中(key, value)的关系 </li><li>节点的子节点children </li><li>节点的状态stat：用来描述当前节点的创建、修改记录，包括cZxid、ctime等</li></ul><h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><p>zookeeper中的节点有两种，分别为临时节点和永久节点。节点的类型在创建时即 被确定，并且不能改变。 </p><ul><li>临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临 时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到 一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节 点不允许拥有子节点。</li><li> 持久化节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作 的时候，他们才能被删除</li></ul><h3 id="zookeeper单机安装"><a href="#zookeeper单机安装" class="headerlink" title="zookeeper单机安装"></a>zookeeper单机安装</h3><p>当前测试系统环境centos7.3 </p><p>jdk:jdk-8u131-linux-x64.tar.gz </p><p>zookeeper:zookeeper-3.4.10.tar.gz </p><ol><li>在centos中使用root用户创建zookeeper用户，用户名：zookeeper 密 码:zookeeper</li></ol><blockquote><p>useradd zookeeper </p><p>passwd zookeeper</p></blockquote><ol start="2"><li>zookeeper底层依赖于jdk，zookeeper用户登录后，根目录下先进行jdk的安装，jdk 使用jdk-8u131-linux-x64.tar.gz版本，上传并解压jdk</li></ol><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//解压jdk<br>tar -xzvf jdk-8u131-linux-x64.tar.gz<br></code></pre></div></td></tr></table></figure><ol start="3"><li><p>配置jdk环境变量</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// vim打开 .bash_profile文件<br>vi .bash_profile<br>// 文件中加入如下内容<br>JAVA_HOME=/home/zookeeper/jdk1.8.0_131<br>export JAVA_HOME<br>PATH=$JAVA_HOME/bin:$PATH<br>export PATH<br>// 使环境变量生效<br>. .bash_profile<br></code></pre></div></td></tr></table></figure></li><li><p>检测jdk安装</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">java -version<br></code></pre></div></td></tr></table></figure></li><li><p>zookeeper使用zookeeper-3.4.10.tar.gz，上传并解压</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// 解压zookeeper<br>tar -xzvf zookeeper-3.4.10.tar.gz<br></code></pre></div></td></tr></table></figure></li><li><p>为zookeeper准备配置文件</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// 进入conf目录<br>cd /home/zookeeper/zookeeper-3.4.10/conf<br>// 复制配置文件<br>cp zoo_sample.cfg zoo.cfg<br>// zookeeper根目录下新建data目录<br>mkdir data<br>// vi 修改配置文件中的dataDir<br>// 此路径用于存储zookeeper中数据的内存快照、及事物日志文件<br>dataDir=/home/zookeeper/zookeeper-3.4.10/data<br></code></pre></div></td></tr></table></figure></li><li><p>启动zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// 进入zookeeper的bin目录<br>cd /home/zookeeper/zookeeper-3.4.10/bin<br>// 启动zookeeper<br>./zkServer.sh start<br>//启动：zkServer.sh start<br>//停止：zkServer.sh stop<br>//查看状态：zkServer.sh status<br></code></pre></div></td></tr></table></figure><h3 id="zookeeper常用Shell命令"><a href="#zookeeper常用Shell命令" class="headerlink" title="zookeeper常用Shell命令"></a>zookeeper常用Shell命令</h3></li></ol><h4 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">create [-s] [-e] path data #其中-s 为有序节点，-e 临时节点<br></code></pre></div></td></tr></table></figure><h4 id="创建持久化节点并写入数据"><a href="#创建持久化节点并写入数据" class="headerlink" title="创建持久化节点并写入数据"></a>创建持久化节点并写入数据</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">create /hadoop &quot;123456&quot;<br></code></pre></div></td></tr></table></figure><p>创建持久化有序节点，此时创建的节点名为指定节点名 + 自增序号</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 2] create -s /a &quot;aaa&quot;<br>Created /a0000000000<br>[zk: localhost:2181(CONNECTED) 3] create -s /b &quot;bbb&quot;<br>Created /b0000000001<br>[zk: localhost:2181(CONNECTED) 4] create -s /c &quot;ccc&quot;<br>Created /c0000000002<br></code></pre></div></td></tr></table></figure><p>创建临时节点，临时节点会在会话过期后被删除：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 5] create -e /tmp &quot;tmp&quot;<br>Created /tmp<br></code></pre></div></td></tr></table></figure><p>创建临时有序节点，临时节点会在会话过期后被删除：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 6] create -s -e /aa &#x27;aaa&#x27;<br>Created /aa0000000004<br>[zk: localhost:2181(CONNECTED) 7] create -s -e /bb &#x27;bbb&#x27;<br>Created /bb0000000005<br>[zk: localhost:2181(CONNECTED) 8] create -s -e /cc &#x27;ccc&#x27;<br>Created /cc0000000006<br></code></pre></div></td></tr></table></figure><h4 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h4><p>更新节点的命令是 set ，可以直接进行修改，如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 3] set /hadoop &quot;345&quot;<br>cZxid = 0x4<br>ctime = Thu Dec 12 14:55:53 CST 2019<br>mZxid = 0x5<br>mtime = Thu Dec 12 15:01:59 CST 2019<br>pZxid = 0x4<br>cversion = 0<br>dataVersion = 1<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 3<br>numChildren = 0<br></code></pre></div></td></tr></table></figure><p>也可以基于版本号进行更改，此时类似于乐观锁机制，当你传入的数据版本号 (dataVersion) 和当前节点的数据版本号不符合时，zookeeper 会拒绝本次修改：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 10] set /hadoop &quot;3456&quot; 1<br>version No is not valid : /hadoop<br></code></pre></div></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除节点的语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">delete path [version]<br></code></pre></div></td></tr></table></figure><p>和更新节点数据一样，也可以传入版本号，当你传入的数据版本号 (dataVersion) 和当前节点的数据版本号不符合时，zookeeper 不会执行删除操作。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 36] delete /hadoop 0<br>version No is not valid : /hadoop #无效的版本号<br>[zk: localhost:2181(CONNECTED) 37] delete /hadoop 1<br>[zk: localhost:2181(CONNECTED) 38]<br></code></pre></div></td></tr></table></figure><p>要想删除某个节点及其所有后代节点，可以使用递归删除，命令为<code> rmr path</code>。</p><p>4.2 查看节点</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">get</span> <span class="hljs-type">path</span><br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 1] get /hadoop<br>123456<br>cZxid = 0x4<br>ctime = Thu Dec 12 14:55:53 CST 2019<br>mZxid = 0x4<br>mtime = Thu Dec 12 14:55:53 CST 2019<br>pZxid = 0x4<br>cversion = 0<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 6<br>numChildren = 0<br></code></pre></div></td></tr></table></figure><p>节点各个属性如下表。其中一个重要的概念是 Zxid(ZooKeeper Transaction Id)，ZooKeeper 节点的每一次更改都具有唯一的 Zxid，如果 Zxid1 小于 Zxid2，则 Zxid1 的更改发生在 Zxid2 更改之前。</p><table><thead><tr><th>状态属性</th><th>说明</th></tr></thead><tbody><tr><td>cZxid</td><td>数据节点创建时的事务 ID</td></tr><tr><td>ctime</td><td>数据节点创建时的时间</td></tr><tr><td>mZxid</td><td>数据节点最后一次更新时的事务 ID</td></tr><tr><td>mtime</td><td>数据节点最后一次更新时的时间</td></tr><tr><td>pZxid</td><td>数据节点的子节点最后一次被修改时的事务 ID</td></tr><tr><td>cversion</td><td>子节点的更改次数</td></tr><tr><td>dataVersion</td><td>节点数据的更改次数</td></tr><tr><td>aclVersion</td><td>节点的 ACL 的更改次数</td></tr><tr><td>ephemeralOwner</td><td>如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0</td></tr><tr><td>dataLength</td><td>数据内容的长度</td></tr><tr><td>numChildren</td><td>数据节点当前的子节点个数</td></tr></tbody></table><h4 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h4><p>可以使用<code>stat</code>命令查看节点状态，它的返回值和<code>get</code>命令类似，但不会返回 节点数据</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 2] stat /hadoop<br>cZxid = 0x4<br>ctime = Thu Dec 12 14:55:53 CST 2019<br>mZxid = 0x4<br>mtime = Thu Dec 12 14:55:53 CST 2019<br>pZxid = 0x4<br>cversion = 0<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 6<br>numChildren = 0<br></code></pre></div></td></tr></table></figure><h4 id="查看节点列表"><a href="#查看节点列表" class="headerlink" title="查看节点列表"></a>查看节点列表</h4><p>查看节点列表有<code>ls path</code>和 <code>ls2 path</code> 两个命令，后者是前者的增强，不仅可 以查看指定路径下的所有节点，还可以查看当前节点的信息</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 0] ls /<br>[cluster, controller_epoch, brokers, storm, zookeeper, admin, ...]<br>[zk: localhost:2181(CONNECTED) 1] ls2 /<br>[cluster, controller_epoch, brokers, storm, zookeeper, admin, ....]<br>cZxid = 0x0<br>ctime = Thu Jan 01 08:00:00 CST 1970<br>mZxid = 0x0<br>mtime = Thu Jan 01 08:00:00 CST 1970<br>pZxid = 0x130<br>cversion = 19<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 0<br>numChildren = 11<br></code></pre></div></td></tr></table></figure><h4 id="监听器get-path-watch"><a href="#监听器get-path-watch" class="headerlink" title="监听器get path [watch]"></a>监听器get path [watch]</h4><p>使用<code>get path [watch]</code>注册的监听器能够在节点内容发生改变的时候，向客 户端发出通知。需要注意的是 zookeeper 的触发器是一次性的 (One-time trigger)，即 触发一次后就会立即失效。</p><p>使用 <code>stat path [watch] </code>注册的监听器能够在节点状态发生改变的时候，向客 户端发出通知</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 4] get /hadoop watch<br>[zk: localhost:2181(CONNECTED) 5] set /hadoop 45678<br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeDataChanged path:/hadoop #节点<br>值改变<br></code></pre></div></td></tr></table></figure><h4 id="监听器stat-path-watch"><a href="#监听器stat-path-watch" class="headerlink" title="监听器stat path [watch]"></a>监听器stat path [watch]</h4><p>使用 stat path [watch] 注册的监听器能够在节点状态发生改变的时候，向客 户端发出通知</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 7] stat /hadoop watch<br>[zk: localhost:2181(CONNECTED) 8] set /hadoop 112233<br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeDataChanged path:/hadoop #节点值改变<br></code></pre></div></td></tr></table></figure><h4 id="监听器ls-ls2-path-watch"><a href="#监听器ls-ls2-path-watch" class="headerlink" title="监听器ls\ls2 path [watch]"></a>监听器ls\ls2 path [watch]</h4><p>使用 ls path [watch] 或 ls2 path [watch] 注册的监听器能够监听该节点下 所有子节点的增加和删除操作。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 9] ls /hadoop watch<br>[]<br>[zk: localhost:2181(CONNECTED) 10] create /hadoop/yarn &quot;aaa&quot;<br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/hadoop<br></code></pre></div></td></tr></table></figure><h3 id="zookeeper的acl权限控制"><a href="#zookeeper的acl权限控制" class="headerlink" title="zookeeper的acl权限控制"></a>zookeeper的acl权限控制</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>zookeeper 类似文件系统，client 可以创建节点、更新节点、删除节点，那么如何做到节点的权限的控制呢？zookeeper的access control list 访问控制列表可以做到 这一点。</p></blockquote><p>acl 权限控制，使用scheme：id：permission 来标识，主要涵盖 3 个方面：</p><ul><li><p>权限模式（scheme）：授权的策略</p></li><li><p>授权对象（id）：授权的对象</p></li><li><p>权限（permission）：授予的权限</p><p> 其特性如下：</p></li><li><p>zooKeeper的权限控制是基于每个znode节点的，需要对每个节点设置权限</p></li><li><p>每个znode支持设置多种权限控制方案和多个权限</p></li><li><p>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点 </p><p>例如:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">setAcl /test2 ip:192.168.60.130:crwda // 将节点权限设置为Ip:192.168.60.130的客户端可以对节点进行增、删、改、查、管理权限<br></code></pre></div></td></tr></table></figure><h4 id="权限模式"><a href="#权限模式" class="headerlink" title="权限模式"></a>权限模式</h4></li></ul><p>采用何种方式授权</p><table><thead><tr><th>方案</th><th>描述</th></tr></thead><tbody><tr><td>world</td><td>只有一个用户：anyone，代表登录zokeeper所有人（默认）</td></tr><tr><td>ip</td><td>对客户端使用IP地址认证</td></tr><tr><td>auth</td><td>使用已添加认证的用户认证</td></tr><tr><td>digest</td><td>使用“用户名:密码”方式认证</td></tr></tbody></table><h4 id="授权的对象"><a href="#授权的对象" class="headerlink" title="授权的对象"></a>授权的对象</h4><p>给谁授予权限 </p><p>授权对象ID是指，权限赋予的实体，例如：IP 地址或用户。</p><h4 id="授予的权限"><a href="#授予的权限" class="headerlink" title="授予的权限"></a>授予的权限</h4><p>授予什么权限</p><p> create、delete、read、writer、admin也就是 增、删、改、查、管理权限， 这5种权限简写为cdrwa，注意:这5种权限中，delete是指对子节点的删除权限，其它4种 权限指对自身节点的操作权限</p><table><thead><tr><th>权限</th><th>ACL简写</th><th>描述</th></tr></thead><tbody><tr><td>create</td><td>c</td><td>可以创建子节点</td></tr><tr><td>delete</td><td>d</td><td>可以删除子节点（仅下一级节点）</td></tr><tr><td>read</td><td>r</td><td>可以读取节点数据及显示子节点列表</td></tr><tr><td>write</td><td>w</td><td>可以设置节点数据</td></tr><tr><td>admin</td><td>a</td><td>可以设置节点访问控制列表权限</td></tr></tbody></table><h4 id="授权的相关命令"><a href="#授权的相关命令" class="headerlink" title="授权的相关命令"></a>授权的相关命令</h4><table><thead><tr><th>命令</th><th>使用方式</th><th>描述</th></tr></thead><tbody><tr><td>getAcl</td><td>getAcl</td><td>读取ACL权限</td></tr><tr><td>setAcl</td><td>setAcl</td><td>设置ACL权限</td></tr><tr><td>addauth</td><td>addauth</td><td>添加认证用户</td></tr></tbody></table><h3 id="zookeeper-javaAPI"><a href="#zookeeper-javaAPI" class="headerlink" title="zookeeper javaAPI"></a>zookeeper javaAPI</h3><p>znode是zooKeeper集合的核心组件，zookeeper API提供了一小组方法使用 zookeeper集合来操纵znode的所有细节。 </p><p>客户端应该遵循以步骤，与zookeeper服务器进行清晰和干净的交互</p><ul><li>连接到zookeeper服务器。zookeeper服务器为客户端分配会话ID。</li><li>定期向服务器发送心跳。否则，zookeeper服务器将过期会话ID，客户端需要重新连 接。</li><li>只要会话ID处于活动状态，就可以获取/设置znode。</li><li>所有任务完成后，断开与zookeeper服务器的连接。如果客户端长时间不活动，则 zookeeper服务器将自动断开客户端。</li></ul><h4 id="连接到ZooKeeper"><a href="#连接到ZooKeeper" class="headerlink" title="连接到ZooKeeper"></a>连接到ZooKeeper</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ZooKeeper(String connectionString, <span class="hljs-keyword">int</span> sessionTimeout, Watcher watcher)<br></code></pre></div></td></tr></table></figure><ul><li>connectionString - zookeeper主机 </li><li>sessionTimeout - 会话超时（以毫秒为单位)</li><li> watcher - 实现“监视器”对象。zookeeper集合通过监视器对象返回连接状态。</li></ul><p>案例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<br>        <span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZookeeperConnection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 计数器对象</span><br>            CountDownLatch countDownLatch=<span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// arg1:服务器的ip和端口</span><br><span class="hljs-comment">// arg2:客户端与服务器之间的会话超时时间 以毫秒为单位的</span><br><span class="hljs-comment">// arg3:监视器对象</span><br>            ZooKeeper zooKeeper=<span class="hljs-keyword">new</span> ZooKeeper(<span class="hljs-string">&quot;192.168.60.130:2181&quot;</span>,<br>                    <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>                    <span class="hljs-keyword">if</span>(event.getState()==Event.KeeperState.SyncConnected)<br>                    &#123;<br>                        System.out.println(<span class="hljs-string">&quot;连接创建成功!&quot;</span>);<br>                        countDownLatch.countDown();<br>                    &#125;<br>                &#125;<br>            &#125;);<br><span class="hljs-comment">// 主线程阻塞等待连接对象的创建成功</span><br>            countDownLatch.await();<br><span class="hljs-comment">// 会话编号</span><br>            System.out.println(zooKeeper.getSessionId());<br>            zooKeeper.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="新增节点-1"><a href="#新增节点-1" class="headerlink" title="新增节点"></a>新增节点</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 同步方式</span><br>create(String path, <span class="hljs-keyword">byte</span>[] data, List&lt;ACL&gt; acl,CreateMode createMode)<br><span class="hljs-comment">// 异步方式</span><br>create(String path, <span class="hljs-keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode，AsyncCallback.StringCallback callBack,Object ctx)<br></code></pre></div></td></tr></table></figure><ul><li>path - znode路径。例如，/node1 /node1/node11</li><li>data - 要存储在指定znode路径中的数据</li><li>acl - 要创建的节点的访问控制列表。zookeeper API提供了一个静态接口ZooDefs.Ids 来获取一些基本的acl列表。例如，ZooDefs.Ids.OPEN_ACL_UNSAFE 返回打开znode的acl列表。</li><li>createMode - 节点的类型,这是一个枚举。</li><li>callBack-异步回调接口</li><li>ctx-传递上下文参数</li></ul><p>案例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.zookeeper.*;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.data.ACL;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.data.Id;<br>        <span class="hljs-keyword">import</span> org.junit.After;<br>        <span class="hljs-keyword">import</span> org.junit.Before;<br>        <span class="hljs-keyword">import</span> org.junit.Test;<br>        <span class="hljs-keyword">import</span> java.util.ArrayList;<br>        <span class="hljs-keyword">import</span> java.util.List;<br>        <span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKCreate</span> </span>&#123;<br>    String IP=<span class="hljs-string">&quot;192.168.60.130:2181&quot;</span>;<br>    ZooKeeper zooKeeper;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><span class="hljs-comment">// 计数器对象</span><br>        CountDownLatch countDownLatch=<span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// arg1:服务器的ip和端口</span><br><span class="hljs-comment">// arg2:客户端与服务器之间的会话超时时间 以毫秒为单位的</span><br><span class="hljs-comment">// arg3:监视器对象</span><br>        zooKeeper=<span class="hljs-keyword">new</span> ZooKeeper(IP, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span>(event.getState()==Event.KeeperState.SyncConnected) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;连接创建成功!&quot;</span>);<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">// 主线程阻塞等待连接对象的创建成功</span><br>        countDownLatch.await();<br>    &#125;<br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        zooKeeper.close();<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create1</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><span class="hljs-comment">// arg1:节点的路径</span><br><span class="hljs-comment">// arg2:节点的数据</span><br><span class="hljs-comment">// arg3:权限列表 world:anyone:cdrwa</span><br><span class="hljs-comment">// arg4:节点类型 持久化节点</span><br>        zooKeeper.create(<span class="hljs-string">&quot;/create/node1&quot;</span>,<span class="hljs-string">&quot;node1&quot;</span>.getBytes(),<br>                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// Ids.READ_ACL_UNSAFE world:anyone:r</span><br>        zooKeeper.create(<span class="hljs-string">&quot;/create/node2&quot;</span>, <span class="hljs-string">&quot;node2&quot;</span>.getBytes(),<br>                ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// world授权模式</span><br><span class="hljs-comment">// 权限列表</span><br>        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> ArrayList&lt;ACL&gt;();<br><span class="hljs-comment">// 授权模式和授权对象</span><br>        Id id = <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;anyone&quot;</span>);<br><span class="hljs-comment">// 权限设置</span><br>        acls.add(<span class="hljs-keyword">new</span> ACL(ZooDefs.Perms.READ, id));<br>        acls.add(<span class="hljs-keyword">new</span> ACL(ZooDefs.Perms.WRITE, id));<br>        zooKeeper.create(<span class="hljs-string">&quot;/create/node3&quot;</span>, <span class="hljs-string">&quot;node3&quot;</span>.getBytes(), acls,<br>                CreateMode.PERSISTENT);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// ip授权模式</span><br><span class="hljs-comment">// 权限列表</span><br>        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> ArrayList&lt;ACL&gt;();<br><span class="hljs-comment">// 授权模式和授权对象</span><br>        Id id = <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;ip&quot;</span>, <span class="hljs-string">&quot;192.168.60.130&quot;</span>);<br><span class="hljs-comment">// 权限设置</span><br>        acls.add(<span class="hljs-keyword">new</span> ACL(ZooDefs.Perms.ALL, id));<br>        zooKeeper.create(<span class="hljs-string">&quot;/create/node4&quot;</span>, <span class="hljs-string">&quot;node4&quot;</span>.getBytes(), acls,<br>                CreateMode.PERSISTENT);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// auth授权模式</span><br><span class="hljs-comment">// 添加授权用户</span><br>        zooKeeper.addAuthInfo(<span class="hljs-string">&quot;digest&quot;</span>, <span class="hljs-string">&quot;itcast:123456&quot;</span>.getBytes());<br>        zooKeeper.create(<span class="hljs-string">&quot;/create/node5&quot;</span>, <span class="hljs-string">&quot;node5&quot;</span>.getBytes(),<br>                ZooDefs.Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create6</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// auth授权模式</span><br><span class="hljs-comment">// 添加授权用户</span><br>        zooKeeper.addAuthInfo(<span class="hljs-string">&quot;digest&quot;</span>, <span class="hljs-string">&quot;itcast:123456&quot;</span>.getBytes());<br><span class="hljs-comment">// 权限列表</span><br>        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> ArrayList&lt;ACL&gt;();<br><span class="hljs-comment">// 授权模式和授权对象</span><br>        Id id = <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;auth&quot;</span>, <span class="hljs-string">&quot;itcast&quot;</span>);<br><span class="hljs-comment">// 权限设置</span><br>        acls.add(<span class="hljs-keyword">new</span> ACL(ZooDefs.Perms.READ, id));<br>        zooKeeper.create(<span class="hljs-string">&quot;/create/node6&quot;</span>, <span class="hljs-string">&quot;node6&quot;</span>.getBytes(), acls,<br>                CreateMode.PERSISTENT);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create7</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// digest授权模式</span><br><span class="hljs-comment">// 权限列表</span><br>        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> ArrayList&lt;ACL&gt;();<br><span class="hljs-comment">// 授权模式和授权对象</span><br>        Id id = <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;digest&quot;</span>, <span class="hljs-string">&quot;itheima:qlzQzCLKhBROghkooLvb+Mlwv4A=&quot;</span>);<br><span class="hljs-comment">// 权限设置</span><br>        acls.add(<span class="hljs-keyword">new</span> ACL(ZooDefs.Perms.ALL, id));<br>        zooKeeper.create(<span class="hljs-string">&quot;/create/node7&quot;</span>, <span class="hljs-string">&quot;node7&quot;</span>.getBytes(), acls,<br>                CreateMode.PERSISTENT);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create8</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 持久化顺序节点</span><br><span class="hljs-comment">// Ids.OPEN_ACL_UNSAFE world:anyone:cdrwa</span><br>        String result = zooKeeper.create(<span class="hljs-string">&quot;/create/node8&quot;</span>,<br>                <span class="hljs-string">&quot;node8&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,<br>                CreateMode.PERSISTENT_SEQUENTIAL);<br>        System.out.println(result);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 临时节点</span><br><span class="hljs-comment">// Ids.OPEN_ACL_UNSAFE world:anyone:cdrwa</span><br>        String result = zooKeeper.create(<span class="hljs-string">&quot;/create/node9&quot;</span>,<br>                <span class="hljs-string">&quot;node9&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br>        System.out.println(result);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create10</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 临时顺序节点</span><br><span class="hljs-comment">// Ids.OPEN_ACL_UNSAFE world:anyone:cdrwa</span><br>        String result = zooKeeper.create(<span class="hljs-string">&quot;/create/node10&quot;</span>,<br>                <span class="hljs-string">&quot;node10&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,<br>                CreateMode.EPHEMERAL_SEQUENTIAL);<br>        System.out.println(result);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create11</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 异步方式创建节点</span><br>        zooKeeper.create(<span class="hljs-string">&quot;/create/node11&quot;</span>, <span class="hljs-string">&quot;node11&quot;</span>.getBytes(),<br>                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="hljs-keyword">new</span><br>                        AsyncCallback.StringCallback() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rc, String path, Object ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                      String name)</span> </span>&#123;<br><span class="hljs-comment">// 0 代表创建成功</span><br>                                System.out.println(rc);<br><span class="hljs-comment">// 节点的路径</span><br>                                System.out.println(path);<br><span class="hljs-comment">// 节点的路径</span><br>                                System.out.println(name);<br><span class="hljs-comment">// 上下文参数</span><br>                                System.out.println(ctx);<br>                            &#125;<br>                        &#125;, <span class="hljs-string">&quot;I am context&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="更新节点-1"><a href="#更新节点-1" class="headerlink" title="更新节点"></a>更新节点</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 同步方式</span><br>setData(String path, <span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">int</span> version)<br><span class="hljs-comment">// 异步方式</span><br>setData(String path, <span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">int</span> version，AsyncCallback.StatCallback callBack， Object ctx)<br></code></pre></div></td></tr></table></figure><ul><li>path- znode路径 </li><li>data - 要存储在指定znode路径中的数据。</li><li> version- znode的当前版本。每当数据更改时，ZooKeeper会更新znode的版本 号。 </li><li>callBack-异步回调接口 </li><li>ctx-传递上下文参数</li></ul><p>案例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.zookeeper.*;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<br>        <span class="hljs-keyword">import</span> org.junit.After;<br>        <span class="hljs-keyword">import</span> org.junit.Before;<br>        <span class="hljs-keyword">import</span> org.junit.Test;<br>        <span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKSet</span> </span>&#123;<br>    String IP = <span class="hljs-string">&quot;192.168.60.130:2181&quot;</span>;<br>    ZooKeeper zookeeper;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// arg1:zookeeper服务器的ip地址和端口号</span><br><span class="hljs-comment">// arg2:连接的超时时间 以毫秒为单位</span><br><span class="hljs-comment">// arg3:监听器对象</span><br>        zookeeper = <span class="hljs-keyword">new</span> ZooKeeper(IP, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected)<br>                &#123;<br>                    System.out.println(<span class="hljs-string">&quot;连接创建成功!&quot;</span>);<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">// 使主线程阻塞等待</span><br>        countDownLatch.await();<br>    &#125;<br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        zookeeper.close();<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// arg1:节点的路径</span><br><span class="hljs-comment">// arg2:节点修改的数据</span><br><span class="hljs-comment">// arg3:版本号 -1代表版本号不作为修改条件</span><br>        Stat stat=zookeeper.setData(<span class="hljs-string">&quot;/set/node1&quot;</span>,<span class="hljs-string">&quot;node13&quot;</span>.getBytes(),<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 节点的版本号</span><br>        System.out.println(stat.getVersion());<br><span class="hljs-comment">// 节点的创建时间</span><br>        System.out.println(stat.getCtime());<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 异步方式修改节点</span><br>        zookeeper.setData(<span class="hljs-string">&quot;/set/node2&quot;</span>, <span class="hljs-string">&quot;node21&quot;</span>.getBytes(), -<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span><br>                AsyncCallback.StatCallback() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rc, String path, Object ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">                                              Stat stat)</span> </span>&#123;<br><span class="hljs-comment">// 0 代表修改成功</span><br>                        System.out.println(rc);<br><span class="hljs-comment">// 修改节点的路径</span><br>                        System.out.println(path);<br><span class="hljs-comment">// 上线文的参数对象</span><br>                        System.out.println(ctx);<br><span class="hljs-comment">// 的属性信息</span><br>                        System.out.println(stat.getVersion());<br>                    &#125;<br>                &#125;,<span class="hljs-string">&quot;I am Context&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">50000</span>);<br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 同步方式</span><br>delete(String path, <span class="hljs-keyword">int</span> version)<br><span class="hljs-comment">// 异步方式</span><br>delete(String path, <span class="hljs-keyword">int</span> version, AsyncCallback.VoidCallback callBack, Object ctx)<br></code></pre></div></td></tr></table></figure><ul><li>path - znode路径。 </li><li>version - znode的当前版本 </li><li>callBack-异步回调接口 </li><li>ctx-传递上下文参数</li></ul><p>案例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.zookeeper.AsyncCallback;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<br>        <span class="hljs-keyword">import</span> org.junit.After;<br>        <span class="hljs-keyword">import</span> org.junit.Before;<br>        <span class="hljs-keyword">import</span> org.junit.Test;<br>        <span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKDelete</span> </span>&#123;<br>    String IP = <span class="hljs-string">&quot;192.168.60.130:2181&quot;</span>;<br>    ZooKeeper zooKeeper;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// arg1:zookeeper服务器的ip地址和端口号</span><br><span class="hljs-comment">// arg2:连接的超时时间 以毫秒为单位</span><br><span class="hljs-comment">// arg3:监听器对象</span><br>        zooKeeper = <span class="hljs-keyword">new</span> ZooKeeper(IP, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected)<br>                &#123;<br>                    System.out.println(<span class="hljs-string">&quot;连接创建成功!&quot;</span>);<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">// 使主线程阻塞等待</span><br>        countDownLatch.await();<br>    &#125;<br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        zooKeeper.close();<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// arg1:删除节点的节点路径</span><br><span class="hljs-comment">// arg2:数据版本信息 -1代表删除节点时不考虑版本信息</span><br>        zooKeeper.delete(<span class="hljs-string">&quot;/delete/node1&quot;</span>,-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 异步使用方式</span><br>        zooKeeper.delete(<span class="hljs-string">&quot;/delete/node2&quot;</span>, -<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span><br>                AsyncCallback.VoidCallback() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rc, String path, Object ctx)</span> </span>&#123;<br><span class="hljs-comment">// 0代表删除成功</span><br>                        System.out.println(rc);<br><span class="hljs-comment">// 节点的路径</span><br>                        System.out.println(path);<br><span class="hljs-comment">// 上下文参数对象</span><br>                        System.out.println(ctx);<br>                    &#125;<br>                &#125;,<span class="hljs-string">&quot;I am Context&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 同步方式</span><br>getData(String path, <span class="hljs-keyword">boolean</span> b, Stat stat)<br><span class="hljs-comment">// 异步方式</span><br>getData(String path, <span class="hljs-keyword">boolean</span> b, AsyncCallback.DataCallback callBack, Object ctx)<br></code></pre></div></td></tr></table></figure><ul><li>path - znode路径。 </li><li>b- 是否使用连接对象中注册的监视器。</li><li> stat - 返回znode的元数据。 </li><li>callBack-异步回调接口 </li><li>ctx-传递上下文参数</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.zookeeper.AsyncCallback;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<br>        <span class="hljs-keyword">import</span> org.junit.After;<br>        <span class="hljs-keyword">import</span> org.junit.Before;<br>        <span class="hljs-keyword">import</span> org.junit.Test;<br>        <span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKGet</span> </span>&#123;<br>    String IP = <span class="hljs-string">&quot;192.168.60.130:2181&quot;</span>;<br>    ZooKeeper zooKeeper;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// arg1:zookeeper服务器的ip地址和端口号</span><br><span class="hljs-comment">// arg2:连接的超时时间 以毫秒为单位</span><br><span class="hljs-comment">// arg3:监听器对象</span><br>        zooKeeper = <span class="hljs-keyword">new</span> ZooKeeper(IP, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected)<br>                &#123;<br>                    System.out.println(<span class="hljs-string">&quot;连接创建成功!&quot;</span>);<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">// 使主线程阻塞等待</span><br>        countDownLatch.await();<br>    &#125;<br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        zooKeeper.close();<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// arg1:节点的路径</span><br><span class="hljs-comment">// arg3:读取节点属性的对象</span><br>        Stat stat=<span class="hljs-keyword">new</span> Stat();<br>        <span class="hljs-keyword">byte</span> [] bys=zooKeeper.getData(<span class="hljs-string">&quot;/get/node1&quot;</span>,<span class="hljs-keyword">false</span>,stat);<br><span class="hljs-comment">// 打印数据</span><br>        System.out.println(<span class="hljs-keyword">new</span> String(bys));<br><span class="hljs-comment">// 版本信息</span><br>        System.out.println(stat.getVersion());<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">//异步方式</span><br>        zooKeeper.getData(<span class="hljs-string">&quot;/get/node1&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">new</span><br>                AsyncCallback.DataCallback() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rc, String path, Object ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">                                              <span class="hljs-keyword">byte</span>[] data, Stat stat)</span> </span>&#123;<br><span class="hljs-comment">// 0代表读取成功</span><br>                        System.out.println(rc);<br><span class="hljs-comment">// 节点的路径</span><br>                        System.out.println(path);<br><span class="hljs-comment">// 上下文参数对象</span><br>                        System.out.println(ctx);<br><span class="hljs-comment">// 数据</span><br>                        System.out.println(<span class="hljs-keyword">new</span> String(data));<br><span class="hljs-comment">// 属性对象</span><br>                        System.out.println(stat.getVersion());<br>                    &#125;<br>                &#125;,<span class="hljs-string">&quot;I am Context&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="查看子节点"><a href="#查看子节点" class="headerlink" title="查看子节点"></a>查看子节点</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 同步方式</span><br>getChildren(String path, <span class="hljs-keyword">boolean</span> b)<br><span class="hljs-comment">// 异步方式</span><br>getChildren(String path, <span class="hljs-keyword">boolean</span> b, AsyncCallback.ChildrenCallback callBack,Object ctx)<br></code></pre></div></td></tr></table></figure><ul><li>path - Znode路径。 </li><li>b- 是否使用连接对象中注册的监视器。</li><li> callBack - 异步回调接口。</li><li> ctx-传递上下文参数</li></ul><p>案例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.zookeeper.AsyncCallback;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<br>        <span class="hljs-keyword">import</span> org.junit.After;<br>        <span class="hljs-keyword">import</span> org.junit.Before;<br>        <span class="hljs-keyword">import</span> org.junit.Test;<br>        <span class="hljs-keyword">import</span> java.util.List;<br>        <span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKGetChid</span> </span>&#123;<br>    String IP = <span class="hljs-string">&quot;192.168.60.130:2181&quot;</span>;<br>    ZooKeeper zooKeeper;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// arg1:zookeeper服务器的ip地址和端口号</span><br><span class="hljs-comment">// arg2:连接的超时时间 以毫秒为单位</span><br><span class="hljs-comment">// arg3:监听器对象</span><br>        zooKeeper = <span class="hljs-keyword">new</span> ZooKeeper(IP, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected)<br>                &#123;<br>                    System.out.println(<span class="hljs-string">&quot;连接创建成功!&quot;</span>);<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">// 使主线程阻塞等待</span><br>        countDownLatch.await();<br>    &#125;<br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        zooKeeper.close();<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// arg1:节点的路径</span><br>        List&lt;String&gt; list = zooKeeper.getChildren(<span class="hljs-string">&quot;/get&quot;</span>, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">for</span> (String str : list) &#123;<br>            System.out.println(str);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 异步用法</span><br>        zooKeeper.getChildren(<span class="hljs-string">&quot;/get&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">new</span><br>                AsyncCallback.ChildrenCallback() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rc, String path, Object ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">                                              List&lt;String&gt; children)</span> </span>&#123;<br><span class="hljs-comment">// 0代表读取成功</span><br>                        System.out.println(rc);<br><span class="hljs-comment">// 节点的路径</span><br>                        System.out.println(path);<br><span class="hljs-comment">// 上下文参数对象</span><br>                        System.out.println(ctx);<br><span class="hljs-comment">// 子节点信息</span><br>                        <span class="hljs-keyword">for</span> (String str : children) &#123;<br>                            System.out.println(str);<br>                        &#125;<br>                    &#125;<br>                &#125;,<span class="hljs-string">&quot;I am Context&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 同步方法</span><br>exists(String path, <span class="hljs-keyword">boolean</span> b)<br><span class="hljs-comment">// 异步方法</span><br>exists(String path, <span class="hljs-keyword">boolean</span> b, AsyncCallback.StatCallback callBack,Object ctx)<br></code></pre></div></td></tr></table></figure><ul><li>path- znode路径。 </li><li>b- 是否使用连接对象中注册的监视器。</li><li> callBack - 异步回调接口。</li><li> ctx-传递上下文参数</li></ul><p>案例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.zookeeper.AsyncCallback;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<br>        <span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<br>        <span class="hljs-keyword">import</span> org.junit.After;<br>        <span class="hljs-keyword">import</span> org.junit.Before;<br>        <span class="hljs-keyword">import</span> org.junit.Test;<br>        <span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKExists</span> </span>&#123;<br>    String IP = <span class="hljs-string">&quot;192.168.60.130:2181&quot;</span>;<br>    ZooKeeper zookeeper;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// arg1:zookeeper服务器的ip地址和端口号</span><br><span class="hljs-comment">// arg2:连接的超时时间 以毫秒为单位</span><br><span class="hljs-comment">// arg3:监听器对象</span><br>        zookeeper = <span class="hljs-keyword">new</span> ZooKeeper(IP, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected)<br>                &#123;<br>                    System.out.println(<span class="hljs-string">&quot;连接创建成功!&quot;</span>);<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">// 使主线程阻塞等待</span><br>        countDownLatch.await();<br>    &#125;<br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        zookeeper.close();<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exists1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// arg1:节点的路径</span><br>        Stat stat = zookeeper.exists(<span class="hljs-string">&quot;/exists1&quot;</span>, <span class="hljs-keyword">false</span>);<br>        System.out.println(stat.getVersion());<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exists2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 异步使用方式</span><br>        zookeeper.exists(<span class="hljs-string">&quot;/exists1&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">new</span><br>                AsyncCallback.StatCallback() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rc, String path, Object ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">                                              Stat stat)</span> </span>&#123;<br><span class="hljs-comment">// 0 判断成功</span><br>                        System.out.println(rc);<br><span class="hljs-comment">// 路径</span><br>                        System.out.println(path);<br><span class="hljs-comment">// 上下文参数</span><br>                        System.out.println(ctx);<br><span class="hljs-comment">// null 节点不存在</span><br>                        System.out.println(stat.getVersion());<br>                    &#125;<br>                &#125;, <span class="hljs-string">&quot;I am Context&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>分布式中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死磕LVS，实现Nginx集群高可用</title>
    <link href="/2021/01/23/%E6%AD%BB%E7%A3%95LVS%EF%BC%8C%E5%AE%9E%E7%8E%B0Nginx%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <url>/2021/01/23/%E6%AD%BB%E7%A3%95LVS%EF%BC%8C%E5%AE%9E%E7%8E%B0Nginx%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是LVS？"><a href="#什么是LVS？" class="headerlink" title="什么是LVS？"></a>什么是LVS？</h2><img src="https://img.wclblog.top/images/lvs/01.jpg" srcset="/img/loading.gif"><blockquote><p>LVS的全称为 Linux Virtual Server，它是一个在Linux操作系统上的虚拟服务。</p><p>由章文嵩博士主导的开源负载均衡项目</p></blockquote><div class="note note-info">            <p><strong>高文嵩</strong> </p><p>历任淘宝网资深技术总监、淘宝技术委员会主席、阿里副总裁、阿里开源委员会主席、阿里云CTO等。目前任滴滴高级副总裁。</p>          </div><h3 id="为什么要使用LVS"><a href="#为什么要使用LVS" class="headerlink" title="为什么要使用LVS?"></a>为什么要使用LVS?</h3><p>LVS是一种基于四层负载均衡的调度器，相对于Nginx而言，它可以处理更多的并发请求。性能是nginx的N倍。</p><p>LVS是基于四层负载的，而Nginx是基于七层负载。</p><p>四层负载：四层负载是对于ip+端口号进行的负载均衡，收到请求后会直接转发。</p><p>七层负载：七层负载也是内容转换，是在应用层对请求报文进行的负载均衡。</p><h3 id="LVS三种模式"><a href="#LVS三种模式" class="headerlink" title="LVS三种模式"></a>LVS三种模式</h3><ol><li><p>NAT模式</p><p>NAT模式即网络地址转换，当用户发起请求，服务器会将响应返回给LVS，同时LVS会绑定一个vip即虚拟ip，这个虚拟ip是暴露在公网上的，然后通过这个虚拟ip将相应返回给用户。</p></li><li><p>TUN模式</p><p>这种模式是一种Ip隧道模式，这个模式要求所有计算机节点有一个网卡，这个网卡就是用来建立隧道的，通过建立隧道才能达成通讯，当我们使用了这种模式后，用户所有的响应是不会经过LVS的，所有的服务器节点它们会把各自的报文直接响应返回给用户，这样的话LVS的压力就大大降低了。</p><p>但是这种模式要有一个硬性要求，就是所有节点必须配备一个网卡。并且所有服务器节点都处于公网下。</p></li><li><p>DR模式</p><p>DR模式就是直接路由模式，当服务器收到请求后它会通过一个Router然后返回给用户，并不会单独返回给用户了。同样也会通过虚拟ip返回给用户。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>负载均衡</category>
      
      <category>LVS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LVS</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx入门到入神</title>
    <link href="/2021/01/16/Nginx%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%A5%9E/"/>
    <url>/2021/01/16/Nginx%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%A5%9E/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h2><ol><li><p>去官网<a href="http://nginx.org下载对应的nginx包,推荐使用稳定版本/">http://nginx.org下载对应的nginx包，推荐使用稳定版本</a></p></li><li><p>上传nginx到linux 服务器</p></li><li><p>安装依赖环境</p><ol><li><p>安装gcc环境</p><p><code>yum install gcc-c++</code></p></li><li><p>安装PCRE库，用于解析正则表达式</p><p><code>yum install -y pcre pcre-devel</code></p></li><li><p>zlib压缩和解压缩依赖</p><p><code>yum install -y zlib zlib-devel</code></p></li><li><p>SSL安全的加密套接字协议层，用于HTTP安全传输，即https</p><p><code>yum install -y openssl openssl-devel</code></p></li></ol></li><li><p>解压，需要注意，解压后得到的是源码，源码需要编译后才能安装</p><p><code>tar -zxvf nginx-1.16.1.tar.gz</code></p></li><li><p>编译之前，先创建nginx临时目录，如果不创建，在启动nginx时会报错</p><p><code>mkdir /var/temp/nginx -p</code> </p></li><li><p>在nginx 目录，输入如下命令进行配置，目的是为了创建makefile文件</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs linux">.&#x2F;configure<br>–prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx<br>–pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid<br>–lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock<br>–error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log<br>–http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>–with-http_gzip_static_module<br>–http-client-body-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client<br>–http-proxy-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;proxy<br>–http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;fastcgi<br>–http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;uwsgi<br>–http-scgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;scgi<br></code></pre></div></td></tr></table></figure><ul><li><p>注： 代表在命令行中换行，用于提高可读性</p></li><li><p>配置命令</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>-prefix</td><td>指定nginx安装目录</td></tr><tr><td>-pid-path</td><td>指向nginx的pid</td></tr><tr><td>-lock-path</td><td>锁定安装文件，防止被恶意篡改或误操作</td></tr><tr><td>-error-log</td><td>错误日志</td></tr><tr><td>-http-log-path</td><td>http日志</td></tr><tr><td>-with-http_gzip_static_module</td><td>启用gzip模块，在线实时压缩输出数据流</td></tr><tr><td>-http-client-body-temp-path</td><td>设定客户端请求的临时目录</td></tr><tr><td>-http-proxy-temp-path</td><td>设定http代理临时目录</td></tr><tr><td>–http-fastcgi-temp-path</td><td>设定fastcgi临时目录</td></tr><tr><td>–http-uwsgi-temp-path</td><td>设定uwsgi临时目录</td></tr><tr><td>–http-scgi-temp-path</td><td>设定scgi临时目录</td></tr></tbody></table></li></ul></li><li><p>make编译</p><p><code>make</code></p></li><li><p>安装</p><p><code>make install</code></p></li><li><p>进入sbin目录启动nginx</p><p><code>./nginx</code></p><ul><li>停止： <code>./nginx -s stop</code></li><li>重新加载：<code>./nginx -s reload</code></li></ul></li><li><p>打开浏览器，访问虚拟机所处内网ip即打开nginx默认页面，查看安装是否成功。</p></li></ol><p><strong>注意事项：</strong></p><ol><li> 如果在云服务器安装，需要开启默认的nginx端口：80</li><li>如果在虚拟机安装，需要关闭防火墙<ul><li> 查看防护墙状态：<code>systemctl status firewalld.service</code></li><li> 关闭防火墙：<code> systemctl stop firewalld.service</code> </li><li> 禁用防火墙：<code>systemctl disable firewalld.service</code></li></ul></li><li> 本地win或mac需要关闭防火墙</li></ol><h2 id="Nginx-进程模型"><a href="#Nginx-进程模型" class="headerlink" title="Nginx 进程模型"></a>Nginx 进程模型</h2><ul><li>master：主进程</li><li>worker：工作进程</li></ul><p>查看nginx进程<code>ps -ef|grep nginx</code></p><p>master进程只有一个，worker进程默认情况是一个（可配置）。</p><h3 id="修改Nginx-工作进程数"><a href="#修改Nginx-工作进程数" class="headerlink" title="修改Nginx 工作进程数"></a>修改Nginx 工作进程数</h3><ol><li><p>编辑nginx.conf配置文件</p></li><li><p>在配置文件头部修改 <code>nginx_processes</code>配置，默认有一个</p></li><li><p>检测配置是否无误</p><p>切换到sbin目录，执行<code>./nginx -t</code></p></li><li><p>重载配置文件</p><p><code>nginx -s reload</code></p></li><li><p>查看nginx进程</p><p><code>ps -ef|grep nginx</code></p></li></ol><h2 id="Nginx处理Web请求机制"><a href="#Nginx处理Web请求机制" class="headerlink" title="Nginx处理Web请求机制"></a>Nginx处理Web请求机制</h2><h3 id="Worker抢占机制"><a href="#Worker抢占机制" class="headerlink" title="Worker抢占机制"></a>Worker抢占机制</h3><img src="https://img.wclblog.top/images/nginx/01.png" srcset="/img/loading.gif"><p>如图所示，假如worker进程有三个，当请求来的时候，在client和worker之间会有一把锁（accept_mutex），三个worker会抢占这把锁，比如worker1抢到锁，那么他就会处理这个请求。</p><h3 id="传统服务器事件处理"><a href="#传统服务器事件处理" class="headerlink" title="传统服务器事件处理"></a>传统服务器事件处理</h3><img src="https://img.wclblog.top/images/nginx/02.png" srcset="/img/loading.gif"><p>如图，我们nginx有一个master进程，和一个worker进程，有一个客户端client1连接进来，来处理一些请求，假设这个请求处理的时间比较久，可能在中间处理的过程中卡住了，那么这个时候，客户端请求就会被阻塞，那么假设阻塞的同时，又有新的客户端连接进来，新的客户端client2 和client3的请求是不能被处理的。只有等到client1请求处理完毕后才会逐个处理client2 和client3的请求。</p><p>这种状况就是同步阻塞的方式，即BIO。</p><h3 id="Nginx事件处理"><a href="#Nginx事件处理" class="headerlink" title="Nginx事件处理"></a>Nginx事件处理</h3><img src="https://img.wclblog.top/images/nginx/03.png" srcset="/img/loading.gif"><p>如图，如果client1连接进来请求发生阻塞，这时候又来了新的连接client2和client3，nginx发现client1阻塞了，那么没有关系，他会继续处理client2如果client也阻塞了，他就会处理client3。</p><p>这主要由于我们的worker1，我们是可以做设置的，在linux中的事件处理机制是使用的epoll模型，epoll是在linux最适合的事件处理模型，如果是windows或者macOS作为服务器的话那么这个是要修改的，否则的话我们使用默认的就可以了。</p><h4 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h4><p>编辑nginx.conf配置文件</p><p>找到events模块</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">event</span> &#123;<br>    <span class="hljs-comment"># 默认使用epoll</span><br>    <span class="hljs-attribute">use</span> <span class="hljs-literal">epoll</span>;<br>    <span class="hljs-comment"># 每个worker允许的客户端最大连接数</span><br>    <span class="hljs-attribute">worker_connection</span> <span class="hljs-number">1024</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Nginx能够处理高并发量请求原因"><a href="#Nginx能够处理高并发量请求原因" class="headerlink" title="Nginx能够处理高并发量请求原因"></a>Nginx能够处理高并发量请求原因</h3><ol><li>worker抢占机制</li><li>异步非阻塞事件处理模型（多路复用器）</li></ol><h2 id="Nginx-conf配置结构"><a href="#Nginx-conf配置结构" class="headerlink" title="Nginx.conf配置结构"></a>Nginx.conf配置结构</h2><ol><li>main 全局配置<ol><li>event 配置工作模式以及连接数</li><li>http http模块相关的配置<ol><li>server 虚拟主机配置，可以有多个<ol><li>location 路由规则，表达式</li><li>upstream 集群，内网服务器</li></ol></li></ol></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比起失败，我选择不留遗憾。</title>
    <link href="/2021/01/16/%E6%AF%94%E8%B5%B7%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%B8%8D%E7%95%99%E9%81%97%E6%86%BE%E3%80%82/"/>
    <url>/2021/01/16/%E6%AF%94%E8%B5%B7%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%B8%8D%E7%95%99%E9%81%97%E6%86%BE%E3%80%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center>遗憾比失败更可悲</center><p>“我是林一，一败如水的一，一塌糊涂的一，一无是处的一”。电影里的这句台词，感觉和此时的我产生了共鸣。 </p><p>寒风入骨，独自一人漂泊在北京，每当想到家的时候，不禁产生了一种心酸的感觉。外面的疫情又开始变得严重起来，想回家看看，却又无所适从。说实话，现在真的想家了。一个人在外打工这段时间，逐渐明白，以后的日子里，只能靠自己了。</p><p>“时光容易把人抛，红了樱桃，绿了芭蕉”。回想起这儿时背的滚瓜烂熟的诗，才终于明白了时光荏苒。</p><p>趁还年轻，要学会敢于尝试，不断挑战自己，才能让自己慢慢成熟。因为只有敢于尝试，才不会留下遗憾。遗憾要比失败更加可悲。</p><p>人生正是因为有失败，才会变得更精彩。</p>]]></content>
    
    
    <categories>
      
      <category>哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人生哲学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT方法论</title>
    <link href="/2021/01/13/AT%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <url>/2021/01/13/AT%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络面试核心</title>
    <link href="/2021/01/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/"/>
    <url>/2021/01/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="TCP相关知识"><a href="#TCP相关知识" class="headerlink" title="TCP相关知识"></a>TCP相关知识</h1><p>这里我先交代一下ip协议和tcp协议</p><p>我们都知道ip协议是无连接的通信协议，它不会占用两个正在通信的计算机之间的通信线路，这样ip就降低了对网络线路的需求，每条线可以同时满足许多不同的计算机间的通信需要，通过ip、消息或者其他数据会被分割成较小的独立的包，并通过因特网在计算机之间传送，ip负责将每个包路由至它的目的地，但ip协议没有做任何事情来确认数据包是否按顺序发送，或者包有没有被破坏，所以ip数据包是不可靠的，需要由它的上层协议来控制。</p><h2 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h2><h3 id="TCP简介"><a href="#TCP简介" class="headerlink" title="TCP简介"></a>TCP简介</h3><p>传输控制协议TCP是传输层的协议，主要具备以下特点</p><ul><li>面向连接的、可靠的、基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul><h3 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h3><img src="https://img.wclblog.top/images/tcp/01.png" srcset="/img/loading.gif"><h4 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h4><p>其中源端口和目的端口各占2个字节</p><p>TCP和UDP的数据包都是不包含ip地址信息的，但是它们均会有源端口和目的端口，也就是说端口这个东西是属于传输层知识范畴的，我们知道在计算机内部进行通信可以有广告、内存共享、信号量、消息队列等方法进行通信的，而两个进程如果需要通信最基本的一个前提是能够唯一的标识一个进程，通过这个唯一标识能够找到对应的进程在本地进程通信中，我们可以使用pid来唯一标识一个进程，但pid只在本地唯一。如果要将两个进程放在不同的计算机上进行通信的话，pid就不够用了。我们就需要在传输层中使用协议端口号，简称端口。我们知道IP层的ip地址可以唯一标识主机，而tcp协议和端口号可以唯一标识主机中的一个进程，这样我们可以利用ip地址+协议+端口号这样一个唯一标识去标识网络中的一个进程。</p><h4 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h4><p>即Sequence Number，它占用4个字节，tcp连接中传送的字节流中的每个字节流都按顺序去编号的，这里序号就起到了作用。</p><h4 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h4><p>即Acknowledment Numbe，同样也是占用四个字节，是期望的下一个报文的第一个序号。</p><h4 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h4><p>表示TCP报文段的首部长度，由于TCP首部包含一个长度可变的选项部分，需要指定这个TCP报文段到底有多长。它指出 TCP 报文段的数据距离 TCP 报文的起始处有多远。</p><h4 id="TCP-Flags"><a href="#TCP-Flags" class="headerlink" title="TCP Flags"></a>TCP Flags</h4><p>即控制位，由8个标志位组成，每一个标志位表示一个控制功能。</p><p>我们主要介绍几个常用的。</p><ul><li>URG：紧急指针标志<ul><li>当为1时表示紧急指针有效</li><li>为0时表示忽略紧急指针</li></ul></li><li>ACK：确认序号标志<ul><li>为1时表示确认序号有效</li><li>为0表示报文中不含确认信息，忽略确认号字段</li></ul></li><li>PSH：push标志<ul><li>为1是带有push标志的数据，指示接收方在接受到该报文段以后应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</li></ul></li><li>RST：重置连接标志<ul><li>用于重置由于主机崩溃或者其他原因而出现错误的连接，或者用于拒绝非法的报文段和拒绝连接请求</li></ul></li><li>SYN：同步序号，用于建立连接过程</li><li>FIN：finish标志，用于释放连接</li></ul><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><p>即滑动窗口的大小，用来告知发送端接收端的缓冲大小，以此控制发送端发送数据的速率，达到流量控制</p><h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>提供额外的可靠性</p><h4 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h4><p>标记紧急数据在数据字段中的位置</p><h4 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h4><p>其长度可变，定义一些其他的可选参数。</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>当应用程序尝试与另一个应用程序进行通信时，他会发送一个通信请求，这个请求必须被发送到一个确切的地址，在双方握手之后tcp将在两个应用之间建立一个全双工的通信，这个全双工的通信将占用两个计算机间的通信线路，直到它被一方或双方关闭为止。</p><p>“握手”是为了建立来连接，TCP三次握手流程图如下：</p><img src="https://img.wclblog.top/images/tcp/02.png" srcset="/img/loading.gif"><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p>最开始的时候呢，我们假设A和B首次进行通信，那么一开始客户端和服务器都是处于CLOSE的状态，主动打开的是客户端，被动打开的是服务端，刚开始的时候TCP服务端进程会创建传输控制块TCB，时刻准备接受其它客户进程发送来的连接请求，此时服务端进入LISTEN即监听的状态。</p><p>此时我们客户端TCP进程也会创建传输控制块TCB，然后向服务器发出连接请求报文，这就是我们报文头里的TCP Flags中的同步序号SYN=1，同时选择一个初始序号seq = x（任意的正数数值），此时TCP客户进程就进入到一个SYN-SENT同步发送的状态。此时发送出的这个报文段也成为SYN报文段，该报文段是不能携带数据的，但是要消耗一个序号，这便是第一次握手了。</p><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>我们的服务器收到请求报文后，如果同意连接，则发出确认报文，确认报文中包含了两个TCPFlags中的SYN = 1，和ACK = 1，那么他的确认号就是x+1。因为在上一次握手中的seq=x，那作为回应，他要回应相关x的信息，并且由于上一个报文消耗了一个序号，因此它就成为了x+1，同时也要为自己的缓存初始化一个序列号，seq=y，此时服务器就进入到了SYN-RCVD，即同步接收的状态，确认报文同样是不能携带数据的，也要消耗一个序号，这便是第二次握手。</p><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p>当TCP客户进程收到确认报文之后，还要给服务器发出一个确认，确认报文的ACK = 1，ack = y+1 ，原因是由于上次握手服务器发送了一个seq=y，同时也消耗了一个序号，作为回应就是y+1，同时上次握手ack告知这次握手要x+1，所以这次的seq就要等于x+1。</p><p>此时TCP连接建立 ，客户端就进入ESTAB-LISHED，即已建立连接的状态，TCP规定这个报文段可以携带数据，但是他也可以不携带，如果不携带的话就不会消耗序号。这便是第三次握手了。当服务器收到确认报文后，也会进入ESTAB-LISHED状态，此后双方就可以开始通信了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>“握手是为了建立连接”，TCP三次握手的流程如下：</p><ul><li>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接</li><li>第一次握手：建立连接时，客户端发送SYN包（syn=j）到服务器，并进入SYN-SEND状态，等待服务器确认。</li><li>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN-RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包，ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTAB-LISHED状态，完成三次握手。</li></ul><h3 id="为什么需要三次握手才能建立连接？"><a href="#为什么需要三次握手才能建立连接？" class="headerlink" title="为什么需要三次握手才能建立连接？"></a>为什么需要三次握手才能建立连接？</h3><ul><li><p>为了初始化Sequence Number的初始值</p><p>通信的双方我互相通知自己初始化的Sequence Number，这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，即TCP会用这个序号来拼接数据，因此在服务器回发它的Sequence Number，即第二次握手之后要发送确认报文给服务器，告知服务器说客户端已经收到你初始化的seq了。</p></li></ul><h3 id="首次握手的隐患——SYN超时"><a href="#首次握手的隐患——SYN超时" class="headerlink" title="首次握手的隐患——SYN超时"></a>首次握手的隐患——SYN超时</h3><p>问题起因分析</p><ul><li>Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认</li><li>Server不断重试直至超时，Linux默认等待63秒才能断开连接</li></ul><p>可能产生SYN Flood攻击的风险，恶意程序可能会给服务器发送SYN这样一个报文，发送之后它就下线了，然后服务器就会默认等待63秒断开连接，这样攻击者就可以把服务器的SYN连接的队列耗尽，让正常的连接请求不能处理。</p><p>防护措施：</p><ul><li><p>SYN满后，通过tcp_syncookies参数回发SYN Cookie来应对这个事。</p><p>当队列满后，TCP会通过源地址端口，目标地址端口和时间戳打造出一个打造出一个特别的Sequence Number回发回去，这个Sequence Number称为SYN Cookie。</p></li><li><p>若正常连接则Client会回发SYN Cookie，直接建立连接</p></li></ul><h3 id="建立连接后，Client出现故障怎么办？"><a href="#建立连接后，Client出现故障怎么办？" class="headerlink" title="建立连接后，Client出现故障怎么办？"></a>建立连接后，Client出现故障怎么办？</h3><p>保活机制</p><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测数仍未收到响应则中断连接。</li></ul><h2 id="谈谈四次挥手"><a href="#谈谈四次挥手" class="headerlink" title="谈谈四次挥手"></a>谈谈四次挥手</h2><p>“挥手“是为了终止连接，TCP四次挥手的流程图如下。</p><img src="https://img.wclblog.top/images/tcp/03.png" srcset="/img/loading.gif"><h3 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h3><p>首先客户端进程发出释放报文，并且停止发出释放数据，在该数据报的报头中tcp Flags中的finish = 1，我们这里假设客户端定义的序列号seq = u,该值等于前面ESTAB-LISHED状态下数据最后一次发送已经传过来的最后一个字节的序号+1，此时客户端就进入到FIN-WAIT-1的终止等待状态，TCP规定即使FIN报文段不携带数据也要消耗掉一个序号</p><h3 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h3><p>当服务器收到连接释放报文后也要发出确认报文即ACK=1 ,作为回应ack = u+1,并且也要初始化一个seq = v</p><p>此时服务端就进入CLOSE-WAIT这样一个关闭 等待的状态，TCP服务器通知高层的应用进程，客户端要释放跟服务器通信的连接，这服务端会处于半关闭的状态，即客户端已经没有数据要发送了，但是服务器若要发送数据，客户端还是能够接受的，这个状态还有持续一段事件，这个状态等于CLOSE-WAIT所持续的事件。</p><h3 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h3><p>客户端收到服务端的确认请求后，此时客户端就会进入FIN-WAIT即终止等待2状态，等待服务器发送释放连接报文，等待发送第三次挥手的请求，因此这段时间内还有可能接受服务器发送的最后的数据，服务器将最后的数据发送完毕后，就会向客户端发送连接释放报文，FIN=1,ack=u+1,由于半关闭的状态，服务器很有可能发送了一些数据，假定此时的数据我们就已经变为了w,此时服务器就进入到LAST-ACK状态，即最后确认状态，等待客户端的最终确认。</p><h3 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h3><p>客户端在收到服务端的释放报文后，必须发出确认， 即ACK=1,ack=w+1,自己的序号也就等于u+1也就是按照客户端发出的上一个报文的序号+1,此时客户端就进入到了TIME-WAIT即时间等待的状态，注意此时客户端的TCP连接还没有释放，必须经过2MSL的时间，这个连接才会真正释放，才进入到CLOSE的状态，MSL即最长报文段寿命，Linux中MSL的值为30s，而服务端收到客户端发来的确认就立即进入CLOSE的状态了，服务器结束TCP连接的时间要比客户端早一些，以上便是四次挥手的主要流程</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>”挥手“是为了终止连接，TCP四次挥手主要流程图如下：</p><ul><li>第一次挥手：Client发送一个FIN,用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态</li><li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态</li><li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手</li></ul><h3 id="为什么会有TIME-WAIT状态？"><a href="#为什么会有TIME-WAIT状态？" class="headerlink" title="为什么会有TIME_WAIT状态？"></a>为什么会有TIME_WAIT状态？</h3><ul><li><p>确保有足够的时间让对方来收到ACK包</p><p>如果被动关闭的那一端没有收到ACK，就会触发被动端重发FIN包，这样一来一去正好是两个MSL</p></li><li><p>避免新旧连接混淆</p><p>有些路由器会缓存ip数据包，如果连接被重用了，那么这些延迟收到的包就有可能跟新连接混在一起</p></li></ul><h3 id="为什么需要四次挥手才能断开连接？"><a href="#为什么需要四次挥手才能断开连接？" class="headerlink" title="为什么需要四次挥手才能断开连接？"></a>为什么需要四次挥手才能断开连接？</h3><p>因为TCP是全双工的，发送方和接收方都需要FIN报文和ACK报文</p><p>所以各需要两次挥手即可，因为另一方是被动的，所以看上去是四次挥手</p><h3 id="服务器出现大量CLOSE-WAIT状态的原因？"><a href="#服务器出现大量CLOSE-WAIT状态的原因？" class="headerlink" title="服务器出现大量CLOSE_WAIT状态的原因？"></a>服务器出现大量CLOSE_WAIT状态的原因？</h3><p>对方关闭socket连接，我方忙于读或写，没有及时关闭连接</p><ul><li><p>检查代码，特别是释放资源的代码</p></li><li><p>检查配置，特别是处理请求的线程配置</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>网络</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入Spring源码，进攻依赖注入逻辑</title>
    <link href="/2021/01/07/%E6%B7%B1%E5%85%A5Spring%E6%BA%90%E7%A0%81%EF%BC%8C%E8%BF%9B%E6%94%BB%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%80%BB%E8%BE%91/"/>
    <url>/2021/01/07/%E6%B7%B1%E5%85%A5Spring%E6%BA%90%E7%A0%81%EF%BC%8C%E8%BF%9B%E6%94%BB%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><blockquote><p>Spring为了实现Bean的生命周期控制，同时也会考虑到自己或者用户在实例化Bean的过程中在每一个阶段都有可能对里面的行为定制化改变，因此，整个输出的过程特别复杂。</p><p>如果说深入到里面的细节无法自拔，不用说大家了，就连小飞龙都已经晕了。</p><p>但是只要抓住了骨架去了解核心部分的话，效果会好很多，因此我们先把脉络摸清，然后去学习细节，就会发现越来越清晰了。</p></blockquote><p>在AbstractApplicationContext中的refresh方法里</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实例化所有剩余的（non-lazy-init非延迟加载的）单例</span><br>beanFactory.preInstantiateSingletons();<br></code></pre></div></td></tr></table></figure><div class="note note-info">            <p>在这个方法里面会初始化那些非延迟加载的bean实例，在我们ApplicationContext容器默认管理的bean都是singleton并且是非延迟加载的。</p><p>所以如果没有特别的设置bean都会在这一步调用getBean方法去进行实例化。</p>          </div><p>所以我们就重点研究getBean 方法，依赖注入也是在这一步完成的。</p><blockquote><p>依赖注入的方式有很多种，我们重点研究根据@Autowired方式进行注入。</p></blockquote><p>要攻克依赖注入，我们就要了解一下要学习的路线：</p><img src="https://img.wclblog.top/images/getBean/01.png" srcset="/img/loading.gif"><p>该路线就是依据@Autowired的注入和解析来进行的。</p><p>接下来我们先大致了解一下每一个模块要做的事情。</p><p>首先是AbstractBeanFactory 它一个抽象类，提供了一个获取bean实例的方法，该方法里面会涉及到一个根据不同的scope去进行不同的处理。</p><p>本文主要研究singleton的情况，因此我们主要来看DefaultSingletonRegistry这个类。看名字我们就能知道，他是单例bean注册的默认实现类，这个类里提供了getSingleton这个方法，用来获取单例实例。</p><p>getSingleton这个方法会尝试从三层的缓存里去获取Bean实例，之所以要分化出三级缓存，主要是用于解决循环依赖的问题。</p><p>如果缓存里没有找到Bean实例，容器就会创建出来，因此就会来到AbstractAutowireCapableBeanFactory里面，这里面会调用createBean方法去做一些创建前的准备工作，之后再调用doCreateBean去创建Bean实例。</p><p>在doCreateBean里面光创建出Bean实例是不行的，还要看看bean实例里面有没有被@Autowired或者@Value之类的依赖注入标签给标记上，如果有则进行相关的标记。而我们的applyMergedBeanDefinitionPostProcessors主要用来对合并后的BeanDefinition做后置处理，此时也涉及到对相关逻辑的处理。</p><p>在进行标记处理之后，则会考虑对Bean的成员变量进行赋值，所以依赖注入也就是在populateBean里面去做实现的。</p><div class="note note-danger">            <p>咱们的突击部队也就只突击到这一层。</p>          </div><p>后面他会经过AutowiredAnnotationBeanPostProcessor的postProcessProperties方法做属性的后置处理，实现Autowired的注入逻辑，逐层深入就会来到DefaultListableBeanFactory去解析依赖关系，这主要因为BeanDefinition都保存在这里，而通过查看BeanDefinition就可以让我们找到Bean之间的依赖关系。</p><p>找到依赖关系之后就会调用DependencyDescriptor这个类里提供的服务去进行注入。</p><p>以上就是整个依赖注入的流程。这里只是说了个大概，实际上远没有这么简单。</p><h2 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h2><img src="https://img.wclblog.top/images/getBean/02.png" srcset="/img/loading.gif"><p>本文我们主要研究getBean 方法，而在getBean方法里真正起作用的是doGetBean方法，我们来看该方法主要做了什么事情。</p><ol><li>首先，他会尝试从容器的缓存里去获取单例Bean实例，这个单例Bean它有可能是Bean或者FactoryBean实例本身，如果是Bean就会直接返回了，如果是FactoryBean那么就会通过getObject方法去返回bean实例。如果在这一步获取不到的话，就需要让容器去创建Bean了。</li><li>接下来是循环依赖的判断逻辑，正是因为有循环依赖才会使用到三级缓存。</li><li>如果当前容器中没有注册该bean的BeanDefinition实例则会递归去父类容器查找</li><li>如果当前容器里面有该bean的BeanDefinition则从容器里获取其实例。</li><li>递归实例化显式依赖的bean 所谓显式就是给bean设置了一个deoends-on</li><li>根据不同的scope采用不同的策略创建Bean实例</li><li>对Bean进行类型检查</li></ol><p>我们直接打开AbstractBeanFactory的doGetBean方法的代码，先看第一行。</p><img src="https://img.wclblog.top/images/getBean/03.png" srcset="/img/loading.gif"><p>第一行就是将getBean传入的这个Bean的名字转换成容器里的真实的beanName，因为传入的名字可能是bean本身也可能是带了&amp;符号的FactoryBean的名字，或者也有可能是传入别名，所以我们要将其统一转换成beanName。</p><p>获取到beanName之后就会进入下一行代码。</p><img src="https://img.wclblog.top/images/getBean/04.png" srcset="/img/loading.gif"><p>通过getSingleton方法尝试从缓存里获取bean实例。进入到这个方法里。</p><img src="https://img.wclblog.top/images/getBean/05.png" srcset="/img/loading.gif"><p>我们就可以看到它调用了一个重载的方法，第二个参数<code>allowEarlyReference</code>为true，允许非延迟加载，也就是立即加载。我们进入到方法里面。</p><img src="https://img.wclblog.top/images/getBean/06.png" srcset="/img/loading.gif"><p>这个方法是在DefaultSingletonBeanRegistry类里，同过类名我们也能知道，主要负责对容器创建出来的单例进行注册的。</p><p>他首先会尝试从一个singletonObjects的一个ConcurrentHashMap里去获取对应于beanName的单例实例，这里的singletonObjects是单例缓存的一级缓存。主要是用来保存最终形态的单例bean实例。</p><p>那么由于我们是第一次调用容器的getBean去提前创建非延迟加载的单例的，所以在以及缓存里是找不到的。于是就会进入下面的if语句，if语句主要是确保从一级缓存里获取不到bean实例并且该实例是正在创建的实例。</p><p>我们进入到这个isSinglesonCurrentlyInCreation方法里。</p><img src="https://img.wclblog.top/images/getBean/07.png" srcset="/img/loading.gif"><p>该方法主要是从singletonsCurrentlyInCreation的一个Set里面</p><img src="https://img.wclblog.top/images/getBean/08.png" srcset="/img/loading.gif"><p>去查找正在创建的单例bean名单里是否有beanName</p><p>在if逻辑里，首先给一级缓存对象加一个同步锁，去操作后面的缓存，以防止线程对缓存的同时操作。</p><p>上锁后就来到earlySingletonObjects由于已经给singletonObjects这个支持多线程操作的一级缓存上锁了，所以对其他缓存的操作都是线程安全的并且同步的，为了提升性能，其他两个缓存都是用的HashMap</p><div class="note note-info">            <p>earlySingletonObjects是还没有去给属性调用populateBean方法去赋值的Bean</p>          </div><p>如果在这一步获取到了，就会直接返回，如果没有获取到，同时allowEarlyReference为true的话，则会进入到if里面尝试从另外一个缓存singletonFactories里去获取，此处为第三层缓存，此处存储的是Bean对应的ObjectFactory实例。看名字我们就能知道这是个对象工厂。</p><img src="https://img.wclblog.top/images/getBean/09.png" srcset="/img/loading.gif"><p>这里面只有一个getObject方法，也就是说后续可以调用getObject方法来创建Bean实例。这个和FactoryBean类似。</p><img src="https://img.wclblog.top/images/getBean/10.png" srcset="/img/loading.gif"><p>回到代码里，如果此处没有获取到工厂实例，则直接返回空对象，如果获取到，那么就会调用getObject方法去获取singleton实例了，此时由于实例的属性可能还没有注入，所以这时将实例放入earlySingletonObjects二级缓存里，为了保证这三级缓存里只有一个是有某个bean的实例的，所以下一步会将其从三级缓存给清除掉。</p><p>——————————————————更新中—————————————————</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>源码品读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入Spring源码，手撕refresh刷新逻辑</title>
    <link href="/2021/01/03/%E6%B7%B1%E5%85%A5Spring%E6%BA%90%E7%A0%81%EF%BC%8C%E6%89%8B%E6%92%95refresh%E5%88%B7%E6%96%B0%E9%80%BB%E8%BE%91/"/>
    <url>/2021/01/03/%E6%B7%B1%E5%85%A5Spring%E6%BA%90%E7%A0%81%EF%BC%8C%E6%89%8B%E6%92%95refresh%E5%88%B7%E6%96%B0%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-info">            <p>在研究refresh方法之前呢，我们先要了解一些必要的知识</p><ul><li>PostProcessor</li><li>Aware</li><li>Spring事件驱动模型</li></ul>          </div><h2 id="后置处理器PostProcessor"><a href="#后置处理器PostProcessor" class="headerlink" title="后置处理器PostProcessor"></a>后置处理器PostProcessor</h2><blockquote><p>Spring框架里提供了各种PostProcessor作为容器或者Bean的后置处理器</p><p>其实这些PostProcessor本身也是一种需要注册到容器里的Bean</p></blockquote><ul><li>其里面的方法会在特定的时机被容器调用。</li><li>实现不改变容器或者Bean核心逻辑的情况下对Bean进行扩展</li><li>对Bean进行包装，影响其行为，修改Bean的内容</li></ul><h3 id="PostProcessor的种类"><a href="#PostProcessor的种类" class="headerlink" title="PostProcessor的种类"></a>PostProcessor的种类</h3><p><strong>大致分为容器级别的后置处理器以及Bean级别的后置处理器</strong></p><ul><li>BeanDefinitionRegistryPostProcessor</li><li>BeanFactoryPostProcessor</li><li>BeanPostProcessor</li></ul><h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h4><img src="https://img.wclblog.top/images/refresh/01.png" srcset="/img/loading.gif"><p>进入到源码里面我们可以看到BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor,</p><p>它本身也就是一种特殊的BeanFactoryPostProcessor</p><p>里面仅提供了一个方法</p><img src="https://img.wclblog.top/images/refresh/02.png" srcset="/img/loading.gif"><blockquote><p>该方法接收registry参数，光看方法声明信息就可以知道，我们需要在方法体里面创建出BeanDefinition实例，通过传入的registry，将我们的BeanDefinition注册到registry里面</p></blockquote><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>在BeanPostProcessor方法中主要提供了两个方法</p><img src="https://img.wclblog.top/images/refresh/03.png" srcset="/img/loading.gif"><ul><li><p>postProcessBeforeInitialization</p><p>Bean初始化之前要做的事情</p></li><li><p>postProcessAfterInitialization</p><p>Bean初始化之后要做的事情</p></li></ul><h2 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h2><div class="note note-secondary">            <p>容器对Bean本身基本上无侵入的，因此Bean一般不需要了解容器的状态和直接使用容器</p><p>但是在某些情况下是需要在Bean中直接对容器进行操作的，这时候就需要在Bean中设置对容器的感知了</p><p>这便是Aware的作用</p>          </div><img src="https://img.wclblog.top/images/refresh/04.png" srcset="/img/loading.gif"><p>在Aware中我们可以看到是没有任何方法的，只能当作标签来使用，所以Aware在Spring中能直接发挥作用的是其自带的继承了Aware接口的子接口。</p><p>常见的Aware接口如下：</p><ul><li>ApplicationContextAware</li><li>MessageSourceAware</li><li>ApplicationEventPublisherAware</li><li>BeanFactoryAware</li><li>ResourceLoaderAware</li><li>BeanNameAware</li></ul><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><img src="https://img.wclblog.top/images/refresh/05.png" srcset="/img/loading.gif"><p>着这个接口里面我们可以看到它定义了一个<code>setApplicationContext</code>的方法。</p><blockquote><p>这个方法是让实现了该接口的Bean在容器创建这个Bean实例的时候将容器本身的实例作为参数传进来给这个Bean使用</p></blockquote><h3 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h3><img src="https://img.wclblog.top/images/refresh/06.png" srcset="/img/loading.gif"><p>在这个接口里我们也可以看到也定义了一个方法<code>setBeanName</code></p><blockquote><p>该方法的作用就是用来将Bean的名字传入进来供该接口的实现类使用</p></blockquote><p>其他的接口我们看名字也就能知道了</p><p>BeanFactoryAware主要用于获取当前的BeanFactory这样就可以调用容器的服务</p><p>MessageSourceAware主要用来获取MessageSource相关的文本信息</p><p>ApplicationEventPublisherAware主要用来获取发布器实例来发布事件的</p><p>ResourceLoadAware主要用来获取资源加载器，通过资源加载器我们可以获取外部资源文件</p><h2 id="Spring事件驱动模型"><a href="#Spring事件驱动模型" class="headerlink" title="Spring事件驱动模型"></a>Spring事件驱动模型</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><img src="https://img.wclblog.top/images/refresh/07.png" srcset="/img/loading.gif"><ul><li><p>ContextStoppedEvent</p><p>容器停止后触发的事件</p></li><li><p>ContextRefreshedEvent</p><p>容器初始化或刷新完成后触发的事件</p></li><li><p>ContextCloseEvent</p><p>容器关闭后触发的事件</p></li><li><p>ContextStartedEvent</p><p>容器启动后触发的事件</p></li></ul><h3 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h3><img src="https://img.wclblog.top/images/refresh/08.png" srcset="/img/loading.gif"><p>在ApplicationListener中只有一个方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Handle an application event.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> event the event to respond to</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(E event)</span></span>;<br></code></pre></div></td></tr></table></figure><p>该方法是用来处理事件的</p><p>Spring还实现了两个ApplicationListener的子接口，提供了事件筛选的能力。</p><p>SmartApplicationListener和GenericApplicationListener均继承了Ordered接口，具备了排序的能力，按照从小到大的顺序给监听器一个优先级，从而保证执行的顺序</p><h3 id="事件发布器"><a href="#事件发布器" class="headerlink" title="事件发布器"></a>事件发布器</h3><blockquote><p>通过事件发布器，Spring便具备了事件发布的能力</p></blockquote><h4 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h4><img src="https://img.wclblog.top/images/refresh/09.png" srcset="/img/loading.gif"><p>这个接口只提供了两个方法，均和事件发布相关，也就是说我们这个接口只能用于发布事件</p><h4 id="ApplicationEventMulticaster"><a href="#ApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster"></a>ApplicationEventMulticaster</h4><img src="https://img.wclblog.top/images/refresh/10.png" srcset="/img/loading.gif"><p>这个接口提供了添加删除ApplicationListener的方法同时还提供了发布事件的方法</p><p>看一下ApplicationEventMulticaster主要的家族成员</p><img src="https://img.wclblog.top/images/refresh/11.png" srcset="/img/loading.gif"><p>提供了AbstractApplicationEventMulticaster作为其默认实现</p><p>在该类中提供了一个<code>defaultRetriever</code>的成员变量，他是用来保存注册进来的Listener的</p><p>因为AbstractApplicationEventMulticaster仅是抽象类如果本地没有AbstractApplicationEventMulticaster的实现就会使用默认的SimpleApplicationEventMulticaster这个实现。</p><img src="https://img.wclblog.top/images/refresh/12.png" srcset="/img/loading.gif"><blockquote><p>我们可以看到他有个成员变量Executor任务执行器，也就意味着它支持多线程处理监听器的方法</p></blockquote><p>我们看到里面一个multicastEvent方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;<br>ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));<br>Executor executor = getTaskExecutor();<br><span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;<br><span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//多线程异步调用我们提前注册好的ApplicationListener，以多线程的方式处理事件</span><br>executor.execute(() -&gt; invokeListener(listener, event));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//同步挨个执行</span><br>invokeListener(listener, event);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在这个方法里就可以看到，如果有executor的时候就会通过多线程的方式异步调用我们提前注册好的ApplicationListener，以多线程的方式处理事件。</p><p>如果没有则同步挨个执行。</p><p><strong>为什么需要ApplicationEventPublisher和ApplicationEventMulticaster</strong></p><blockquote><p>既然ApplicationEventMulticaster具备了所有的功能，为什么不只使用它来替代掉ApplicationEventPublisher？</p></blockquote><p>我们站在设计者的角度去思考，其实是很容易理解的，像我们针对于Bean和Spring容器本身就只想发布事件，并不想维护事件监听器，所以将事件源做了进一步分割，抽象出事件发布器接口，然后将ApplicationEventMulticaster作为代理让ApplicationEventPublisher的实现类去实现publishEvent()中的逻辑，而publishEvent里面就主要调用ApplicationEventMulticaster实现类里的multicastEvent方法来发布事件就可以了</p><h2 id="向容器刷新逻辑发起进攻"><a href="#向容器刷新逻辑发起进攻" class="headerlink" title="向容器刷新逻辑发起进攻"></a>向容器刷新逻辑发起进攻</h2><div class="note note-danger">            <p>既然我们已经了解了一些前提只是，攻克了第一道防线，那么我们就正式攻克容器初始化这个逻辑</p><p>主要先进攻各类高级容器中通用的部分，即AbstractApplicationContext 中的refresh这个部分</p>          </div><p>先看一下脑图</p><img src="https://img.wclblog.top/images/refresh/13.png" srcset="/img/loading.gif"><p>首先我们先在第一行打一个断点：</p><img src="https://img.wclblog.top/images/refresh/14.png" srcset="/img/loading.gif"><p>编写代码，通过Debug的方式启动容器</p><img src="https://img.wclblog.top/images/refresh/15.png" srcset="/img/loading.gif"><p>我们就可以看到它已经停在这一步了。</p><img src="https://img.wclblog.top/images/refresh/16.png" srcset="/img/loading.gif"><blockquote><p>synchronized这一步主要是给容器加上同步锁，避免容器处在refresh阶段的时候别的线程还在对容器进行初始化或者销毁的操作。</p></blockquote><h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><p>执行StepOver进入下一步执行prepareRefresh的地方，该方法主要是为刷新容器做准备。我们点击StepInto进入方法里面</p><img src="https://img.wclblog.top/images/refresh/17.png" srcset="/img/loading.gif"><p>该方法中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Switch to active.</span><br><span class="hljs-comment">//设置当前时间，也就是容器启动时间，方便后续日志记录，还有容器执行的一些统计工作</span><br><span class="hljs-keyword">this</span>.startupDate = System.currentTimeMillis();<br><span class="hljs-comment">//设置非关闭状态</span><br><span class="hljs-keyword">this</span>.closed.set(<span class="hljs-keyword">false</span>);<br><span class="hljs-comment">//设置为激活状态</span><br><span class="hljs-keyword">this</span>.active.set(<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">//配置日志等级</span><br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Refreshing &quot;</span> + <span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>logger.debug(<span class="hljs-string">&quot;Refreshing &quot;</span> + getDisplayName());<br>&#125;<br>&#125;<br><span class="hljs-comment">//初始化环境(Evironment)的propertySource属性</span><br><span class="hljs-comment">//样例: &lt;context:property-placeholder location=&quot;classpath*:/config/load.properties&quot;/&gt;</span><br>initPropertySources();<br><br><span class="hljs-comment">//校验Environment的requiredProperties是否都存在</span><br>getEnvironment().validateRequiredProperties();<br><br><span class="hljs-comment">//看看容器启动的时候是否有加载一些监听器，默认情况下earlyApplicationListeners为null</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyApplicationListeners == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.earlyApplicationListeners = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-keyword">this</span>.applicationListeners);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">this</span>.applicationListeners.clear();<br><span class="hljs-keyword">this</span>.applicationListeners.addAll(<span class="hljs-keyword">this</span>.earlyApplicationListeners);<br>&#125;<br><span class="hljs-comment">//创建事件集合</span><br><span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br></code></pre></div></td></tr></table></figure><p>执行完这里之后，我们就回到refresh方法里面执行下面的逻辑</p><h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h3><img src="https://img.wclblog.top/images/refresh/18.png" srcset="/img/loading.gif"><p>这时候就进入到了obtainFreshBeanFactory这个方法里面，这一步主要涉及到BeanDefinition的注册</p><p>这一步对于xml配置而言是非常重要的，但是对于注解而言，主要时调用了子类的refreshBeanFactory</p><p>我们进入到这个方法里面</p><img src="https://img.wclblog.top/images/refresh/19.png" srcset="/img/loading.gif"><p>再进入到refreshBeanFactory方法里</p><img src="https://img.wclblog.top/images/refresh/20.png" srcset="/img/loading.gif"><p>我们就会发现它是一个抽象的方法，用来等待我们子类去实现的。因此我们StepInto就会进入到实际的子类里</p><img src="https://img.wclblog.top/images/refresh/21.png" srcset="/img/loading.gif"><blockquote><p>对于注解来讲，它实际是调用的GenericApplicationContext里面的refreshBeanFactory方法</p><p>而在xml配置中调用refreshBeanFactory主要用于生成DefaultListableBeanFactory内部容器实例，然后将BeanDefinition给注册到DefaultListableBeanFactory内部容器实例上</p><p>而针对于我们这里用的注解来讲，就没那么复杂了，DefaultListableBeanFactory在调用容器的构造函数时就创建出来了</p></blockquote><p>因此这里主要就是用于更新AnnotationApplicationContext实例的刷新状态，同时给它内部的DefaultListableBeanFactory设置上serializationId方便外部通过网络来你序列化来获取此处专属的DefaultListableBeanFactory实例</p><p>我们在回到obtainFreshBeanFactory里面，此时他就返回了我们内置的DefaultListableBeanFactory实例了。</p><img src="https://img.wclblog.top/images/refresh/22.png" srcset="/img/loading.gif"><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><p>再StepOver返回到refresh方法里面接下来我们就来到了prepareBeanFactory方法</p><img src="https://img.wclblog.top/images/refresh/23.png" srcset="/img/loading.gif"><blockquote><p>此时我们就已经接受到了DefaultListableBeanFactory实例</p></blockquote><p>继续StepInto进入到prepareBeanFactory方法里面</p><img src="https://img.wclblog.top/images/refresh/24.png" srcset="/img/loading.gif"><p>这个方法主要做了以下事情</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br><span class="hljs-comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span><br><span class="hljs-comment">//告诉内部Bean工厂使用容器的类加载器</span><br>beanFactory.setBeanClassLoader(getClassLoader());<br><span class="hljs-comment">//设置BeanFactory的表达式语言处理器，Spring3开始增加了对语言表达式的支持，默认可以使用#&#123;bean.xxx&#125;获取bean里面的实例值</span><br>beanFactory.setBeanExpressionResolver(<span class="hljs-keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));<br><span class="hljs-comment">//为beanFactory增加一个默认的PropertyEditor</span><br>beanFactory.addPropertyEditorRegistrar(<span class="hljs-keyword">new</span> ResourceEditorRegistrar(<span class="hljs-keyword">this</span>, getEnvironment()));<br><br><span class="hljs-comment">//添加后置处理器，作用是：当应用程序定义的Bean实现ApplicationContextAware接口时注入ApplicationContext对象</span><br>beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationContextAwareProcessor(<span class="hljs-keyword">this</span>));<br><br><span class="hljs-comment">//如果某个Bean依赖于一下某个接口的实现类，在自动装配的时候会忽略他们</span><br><span class="hljs-comment">//Spring会通知其他方式处理这些依赖</span><br>beanFactory.ignoreDependencyInterface(EnvironmentAware.class);<br>beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);<br>beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);<br>beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);<br>beanFactory.ignoreDependencyInterface(MessageSourceAware.class);<br>beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);<br><br><span class="hljs-comment">//修正依赖，这里是注册一些自动装配的特殊规则，比如是BeanFactory class接口的实现类则在运行时指定为当前BeanFactory</span><br>beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);<br>beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="hljs-keyword">this</span>);<br>beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="hljs-keyword">this</span>);<br>beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="hljs-keyword">this</span>);<br><br><span class="hljs-comment">//注册早期后置处理器，用于检测内部bean作为应用程序的监听器</span><br><span class="hljs-comment">//ApplicationListenerDetector的作用就是判断某个Bean是否是ApplicationListener</span><br><span class="hljs-comment">//如果是，加入到事件监听者队列</span><br>beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationListenerDetector(<span class="hljs-keyword">this</span>));<br><br><span class="hljs-comment">// 如果找到一个LoadTimeWeaver，那么就将准备后置处理器“织入”bean工厂</span><br><span class="hljs-keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;<br>beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));<br><span class="hljs-comment">// 为类型匹配设置临时类加载器</span><br>beanFactory.setTempClassLoader(<span class="hljs-keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));<br>&#125;<br><br><span class="hljs-comment">// 注册默认environment环境bean</span><br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;<br>beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());<br>&#125;<br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;<br>beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());<br>&#125;<br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;<br>beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>我们再回到refresh方法里面进入到postProcessBeanFactory方法中。</p><img src="https://img.wclblog.top/images/refresh/25.png" srcset="/img/loading.gif"><blockquote><p>该方法用于允许容器注册必要的postProcess，是一个钩子方法。</p><p>钩子方法就是子类可以实现也可以不实现</p></blockquote><p>我们StepInto进去</p><img src="https://img.wclblog.top/images/refresh/26.png" srcset="/img/loading.gif"><p>就会发现针对于本容器而言是不需要注册子类的PostProcessor的</p><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>继续往下执行，就来到了invokeBeanFactoryPostProcessors这个方法中</p><img src="https://img.wclblog.top/images/refresh/27.png" srcset="/img/loading.gif"><p>这个方法的主要作用是注册容器级别的PostProcessor</p><h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h3><p>我们继续往下执行，就会来到registerBeanPostProcessors这个方法中</p><p>完成容器级别的后置处理器之后就是Bean级别的后置处理器了。</p><div class="note note-info">            <p>registerBeanPostProcessors这一步就是将先前定义的bean级别的后置处理器注册到容器里，方便后续再调用getBean方法创建Bean实例的时候，在特定的各个环节去触发这些后置处理器，执行一些特定的逻辑。</p><p>有了这种Bean级别的后置处理器，就方便于我们对于Bean进行精细化以及自定义管理。</p>          </div><h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h3><p>再往下就进入到了initMessageSource方法</p><img src="https://img.wclblog.top/images/refresh/28.png" srcset="/img/loading.gif"><div class="note note-info">            <p>这里主要进行一些国际化的配置，主要的目的是针对于不同的地区去展示不同的语言内容。</p>          </div><h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h3><p>这里我们就不需要过多关注了，继续往下执行就进入到了<code>initApplicationEventMulticaster();</code></p><blockquote><p>通过这个方法来初始化事件发布器，用来接收实现ApplicationEventPublisher接口的类发送过来的不同的事件并派发给不同的事件监听者进行处理</p></blockquote> <img src="https://img.wclblog.top/images/refresh/29.png" srcset="/img/loading.gif"><p>进入到这个方法里首先我们看到，它首先判断容器先前有没有注册过自定义的事件发布器，如果有直接用</p><p>否则：</p><img src="https://img.wclblog.top/images/refresh/30.png" srcset="/img/loading.gif"><p>就会使用就会使用默认的SimpleApplicationEventMulticaster作为事件发布器。我们StepOver</p><img src="https://img.wclblog.top/images/refresh/31.png" srcset="/img/loading.gif"><p>我们可以看到果然创建了SimpleApplicationEventMulticaster去支持事件发布。</p><p>执行完这里我们就创建完成了SimpleApplicationEventMulticaster，继续走，又回到了refresh方法中。</p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>紧接着执行到了<code>onRefresh()</code>方法</p><img src="https://img.wclblog.top/images/refresh/32.png" srcset="/img/loading.gif"><div class="note note-info">            <p>这个方法也是一个钩子方法</p><p>这个方法主要用来预留给其子类，用于初始化其它特殊的Bean，</p><p>该方法会发生在refresh方法中的finishBeanFactoryInitialization方法之前</p><p>即发生在单例的Bean的实例化之前执行</p><p>onRefresh方法一般用于一些Web容器上</p>          </div><h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h3><p>继续往下执行</p><img src="https://img.wclblog.top/images/refresh/33.png" srcset="/img/loading.gif"><p>这个方法就是向我们之前的ApplicationEventMulticaster去注册监听器，用来监听不同的事件，毕竟光有事件和事件发布器还不能构成完整的事件监听机制，有了监听器就完整了。</p><h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h3><p>继续往下执行便来到了<code>finishBeanFactoryInitialization</code>方法</p><img src="https://img.wclblog.top/images/refresh/34.png" srcset="/img/loading.gif"><p>StepInto进入到这个方法里</p><img src="https://img.wclblog.top/images/refresh/35.png" srcset="/img/loading.gif"><p>我们就会发现该方法首先会判断容器里有没有自动的类型转换器ConversionService，如果有则通过getBean从容器获取提供类型转换的Bean实例，所谓的类型转换器，就是从容器中给Bean实例赋值的时候，将属性值转换为对应的类型。</p><p>只有Spring容器本身不支持的一些类型转换是需要这些转换器来处理的。</p><p>因为我们这里是没有的所以我们继续往下执行便进入到这里</p><img src="https://img.wclblog.top/images/refresh/36.png" srcset="/img/loading.gif"><blockquote><p>这一步的目的就是网容器里注册默认的解析器，这些解析器能解析配置文件中的值，并将他们注入到被@Value注解标记或者Xml里面的配置的${}表达式里</p></blockquote><p>在往后就是获取LoadTimeWeaverAware编织器的bean实例以便进行类加载器的Aop操作</p><img src="https://img.wclblog.top/images/refresh/37.png" srcset="/img/loading.gif"><p>继续往下执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 停止使用临时类加载器进行类型匹配</span><br>beanFactory.setTempClassLoader(<span class="hljs-keyword">null</span>);<br></code></pre></div></td></tr></table></figure><p>然后就是停止使用临时类加载器，因为aop的操作已经完成了，不需要使用临时类加载器加载jvm生成的代理类了。</p><p>再往下执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 允许缓存所有bean定义元数据，不希望有进一步的更改</span><br>beanFactory.freezeConfiguration();<br></code></pre></div></td></tr></table></figure><p>这一步主要用于冻结容器相关的配置这一步使得保存在内存里的先前刷新好的内容变得可靠稳定了</p><p>再看下一步</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 实例化所有剩余的（non-lazy-init非延时加载的）单例</span><br>   beanFactory.preInstantiateSingletons();<br></code></pre></div></td></tr></table></figure><p>这一步就是先实例化剩余所有的默认不是延迟加载的scope为singleton的bean实例</p><p>对于Spring高级容器而言，默认的bean都是singleton并且也不是延迟加载的，所以对应的bean实例就会在此处创建并管理起来</p><p>我们在这一步StepInto进去</p><img src="https://img.wclblog.top/images/refresh/37.png" srcset="/img/loading.gif"><p>我们就会发现它进入到的是DefaultListableBeanFactory这个类里</p><img src="https://img.wclblog.top/images/refresh/38.png" srcset="/img/loading.gif"><p>跳过日志，我们来看下面的逻辑：</p><img src="https://img.wclblog.top/images/refresh/39.png" srcset="/img/loading.gif"><p>首先是遍历注册好的BeanDefinition的名字，然后根据名字去过去相应的BeanDefinition实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);<br></code></pre></div></td></tr></table></figure><p>这里通过RootBeanDefinition接受合并过后的BeanDefinition，getMergedLocalBeanDefinition这个方法调用层级比较深，分析起来比较晕，所以我们只需要记住他的作用就可以了。</p><div class="note note-info">            <p>MergedLocalBeanDefinition的作用就是兼容各种BeanDefinition。</p>          </div><p>不同的Bean在加载SpringBean定义的时候实例化出来的是GenericBeanDefinition，GenericBeanDefinition可以直接转换成RootBeanDefinition，所以对于普通的BeanDefinition这是没有问题的</p><p>而对于另外一种情况，他也是支持的，就是具有继承关系的ChildBeanDefinition，他的parent会指定另外一个BeanDefinition，它就会将ChildBeanDefinition和parent  BeanDefinition的属性给合并到一起，也可以转成RootBeanDefinition并返回。所以为了兼容原先的ChildBeanDefinition，这里用RootBeanDifition是合理的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>       <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;<br>Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;<br><span class="hljs-keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;<br><span class="hljs-keyword">boolean</span> isEagerInit;<br><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> <br>                           &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;<br>isEagerInit = AccessController<br>                               .doPrivileged((PrivilegedAction&lt;Boolean&gt;)<br>((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,<br>getAccessControlContext());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后在这里判断，首先这个BeanDefinition实例不是抽象的，并且是单例且非延迟加载的。</p><p>如果都满足的化，就开始进行实例化了</p><p>然后先判断这个bean是否是FactoryBean，如果是，就会去容器里获取FactoryBean实例。</p><p>如果获取到了之后，再判断FactoryBean里面的Bean是否是延迟加载的，如果不是延迟加载的话<code>isEagerInit</code>，并且相关的创建方法具有权限访问的话<code>getAccessControlContext()</code>,那么就将FactoryBean里面的Bean通过getBean给创建出来。</p><img src="https://img.wclblog.top/images/refresh/40.png" srcset="/img/loading.gif"><p>这里涉及到了一个SmartFactoryBean，我们看一下这个接口。</p><img src="https://img.wclblog.top/images/refresh/41.png" srcset="/img/loading.gif"><p>它可以设置实例是延迟加载还是非延迟加载。</p><p>——————————————————————————————————</p><p>更新中…..</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>源码品读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/2021/01/02/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/01/02/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><blockquote><p>在jdk1.8之前，HashMap底层采用数组+链表的存储结构，jdk1.8之后，引入了红黑树结构，采用数组+链表/红黑树的存储结构。本文主要围绕jdk1.8的hashMap进行分析。</p></blockquote><img src="https://img.wclblog.top/images/hashMap/01.png" srcset="/img/loading.gif"><p>在HashMap中可以看作是通过数组Node[] 这个table 和链表组成的复合结构，在Java8之前数组中的元素称为Entry，Java8之后变为Node，因为引入了树的结构，所以更名为Node更为贴切。</p><img src="https://img.wclblog.top/images/hashMap/02.png" srcset="/img/loading.gif"><blockquote><p>我们看到Node这个类中，主要是由哈希值、键值对、以及指向的下一个节点组成的。</p></blockquote><p>通过哈希值决定了键值对在table中的寻址，哈希值相同的键值对则以链表的形式进行存储</p><img src="https://img.wclblog.top/images/hashMap/03.png" srcset="/img/loading.gif"><blockquote><p>当链表的大小超过<code>TREEIFY_THRESHOLD</code>的时候就会树化，转换为红黑树结构。</p></blockquote><img src="https://img.wclblog.top/images/hashMap/04.png" srcset="/img/loading.gif"><blockquote><p>当树的长度低于<code>UNTREEIFY_THRESHOLD</code>的时候红黑树又被转变为链表，以保证更高的性能。</p></blockquote><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在put方法中我们可以看到，它调用了putVal方法。</p><p>进入到putVal方法中我们看这段代码：</p><img src="https://img.wclblog.top/images/hashMap/05.png" srcset="/img/loading.gif"><p>当table为空的时候或者长度为0的时候，他会调用<code>resize()</code>方法来初始化我们的table，其实resize从名字我们也能得到它的另外一个作用，看到下面的代码：</p><img src="https://img.wclblog.top/images/hashMap/06.png" srcset="/img/loading.gif"><p>当我们size的长度大于阈值的时候同样会调用<code>resize</code>方法，对hashMap进行扩容。</p><p>再回归到putVal逻辑中，在第二个if判断语句中，它会通过</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">i = (n - <span class="hljs-number">1</span>) &amp; hash<br></code></pre></div></td></tr></table></figure><p>进行与运算，算出键值对在table中的具体位置。</p><p>我们看一下在put中传进来的hash</p><img src="https://img.wclblog.top/images/hashMap/07.png" srcset="/img/loading.gif"><p>跟踪到<code>hash()</code>这个方法中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> h;<br>       <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以看到虽然传入的是key，但是返回的并不是key本身的hashCode，而是来自于hash方法的与或所产生的结果。</p><p>再回到putVal方法中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>    <span class="hljs-comment">//如果当通过hash运算得到的结果后，没有元素存储在tab[]中</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">//new一个键值对的Node放到该位置当中</span><br>            tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">//否则</span><br><span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-comment">//再判断如果已经存在键值对，而且键和传入进来的键是一致的</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>               <span class="hljs-comment">//替换原来的元素</span><br>                e = p;<br>            <span class="hljs-comment">//否则判断当前数组位置存储的是否是树化之后的节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-comment">//按照树的方式尝试存储键值对</span><br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>            <span class="hljs-comment">//如果不是树化的节点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-comment">//按照链表的方式往链表后面插入元素</span><br>                        p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                        <span class="hljs-comment">//判断链表的总数 一旦超过TREEIFY_THRESHOLD</span><br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            <span class="hljs-comment">//进行树化</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果插入的键位是存在于hashMap中的</span><br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                V oldValue = e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-comment">//对值进行值的更新操作</span><br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="put逻辑总结"><a href="#put逻辑总结" class="headerlink" title="put逻辑总结"></a>put逻辑总结</h3><p><strong>HashMap：put方法逻辑</strong></p><ol><li>如果HashMap未被初始化，则初始化</li><li>对Key求Hash值，然后再计算下标</li><li>如果没有碰撞，直接放入桶中</li><li>如果碰撞了，以链表的方式链接到后面</li><li>如果链表长度超过阈值，就把链表转换成红黑树</li><li>如果链表长度低于6，就把红黑树转回链表</li><li>如果节点已经存在就替换旧值</li><li>如果桶满了(默认容量16*负载因子0.75)，就需要进行resize(扩容2倍后重排)</li></ol><h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2><p><strong>如何有效减少碰撞</strong></p><ul><li>扰动函数：促使元素位置分布均匀，减少碰撞几率</li><li>使用final对象，并采用合适的equals()和hashCode()方法</li></ul><p>我们来看一下HashMap怎么做的?</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以看出hash方法的实现是比较简单的</p><ul><li>先获取key的hashCode</li><li>再将高位数移动到低位<ul><li>hashCode是int类型的32位，移动到16位，也就是去除了16位的低位</li></ul></li><li>再对原来的数据进行异或运算</li></ul><p>我们可以用一个图来表示一下：</p><img src="https://img.wclblog.top/images/hashMap/08.png" srcset="/img/loading.gif"><p>我们都知道key的hashCode返回的是int，如果直接拿这个散列值作为下标去访问hashMap的数组的话，考虑int的范围是在 -2147483648到2147483648，虽然hash值的映射比较松散，但是这样范围的一个数值，在内存中是放不下的，况且hashMap在扩容之前默认大小是16，所以直接拿这个散列值来用是不现实的。</p><p>所以我们在这里采用了通过高16位向右移16位，再与自己做异或就是混合原始哈希码的高位和低位，以此来加大低位的随机性，而且混合后的低位参杂了高位的特征，让高位的信息也被变相保存下来，这样做的主要目的是从速度，质量等方面来考虑的。可以在素组table的length比较小的时候也能保证考虑到高低bit都参与到哈希的运算当中，同时也不会有太大的开销。</p><p>这样来做主要是通过实际和理论相结合的经验得出来的散列更均匀的做法，并且这样的优化在目前看来 是最有效的。</p><p>通过这样的方法来取代取模的操作，可以有效的提升性能，能有这样的做法也得益于，table的长度是2的n次方。</p><p>我们看一下hashMap的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                              initialCapacity);<br>       <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>           initialCapacity = MAXIMUM_CAPACITY;<br>       <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                              loadFactor);<br>       <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-comment">//通过tableSizeFor(initialCapacity)转换之后的大小</span><br>       <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>   &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>我们可以看到通过构造函数我们可以设置hashMap的初始容量</p><p>但并不是传入的值是多大，它实际就会是多大，它最终是要换算成2的n次方的</p></blockquote><p>看最后tableSizeFor(initialCapacity)方法，</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到通过这个方法最终转换为最接近的2的倍数的值，这样做的目的就是为了通过哈希运算定位桶的时候，可以通过上述的与操作代替取模。</p><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>我们在HashMap中可以看到，默认的负载因子是0.75</p><img src="https://img.wclblog.top/images/hashMap/09.png" srcset="/img/loading.gif"><p>当HashMap的容量达到75%以上的时候，就会调用resize方法进行扩容，扩容的原理是通过生成一个新的原来大小二倍的数组来存放元素</p><p><strong>HashMap扩容问题</strong></p><ul><li>多线程环境下，调整大小会存在条件的竞争，容易造成死锁。</li><li>因为要将原先hashMap中的键值对重新移入一个新的hashMap里面去，这个过程也是一个比较耗时的操作</li></ul><h2 id="如何保证hashMap的线程安全？"><a href="#如何保证hashMap的线程安全？" class="headerlink" title="如何保证hashMap的线程安全？"></a>如何保证hashMap的线程安全？</h2><p>HashMap是线程不安全的，如果想要保证其线程安全，我们可以调用<code>Collections.synchronizedMap();</code> 方法将HashMap包装成一个synchronized的HashMap实例</p><p>当然也可以使用HashTable，HashTable和HashMap主要的区别是在public的方法中都使用了synchronized来修饰。</p><p>但是这两种方式，在多线程的情况下都要去竞争同一把锁，这样导致效率极其低下。</p><p>那么还有没有更好的方式呢？</p><p>答案肯定是有的，我们可以采用在Java5后为了改进HashTable而提出的ConccurentHashMap。</p><p>关于ConccurentHashMap我将会在后期的文章中进行讲解。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给职场新人的建议</title>
    <link href="/2021/01/02/%E7%BB%99%E8%81%8C%E5%9C%BA%E6%96%B0%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
    <url>/2021/01/02/%E7%BB%99%E8%81%8C%E5%9C%BA%E6%96%B0%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="给职场新人的建议"><a href="#给职场新人的建议" class="headerlink" title="给职场新人的建议"></a>给职场新人的建议</h2><h3 id="1-不要有为老板工作的心态"><a href="#1-不要有为老板工作的心态" class="headerlink" title="1 不要有为老板工作的心态"></a>1 不要有为老板工作的心态</h3><p>这就相当于你在学校学习是为了老师学习，或者为了父母学习一样荒谬，你是为了自己工作，你在公司你学到的本事、获得的经验，你离开公司走了，老板又留不下你的肉体，也留不下你的灵魂，你工作带来的成长早晚成为你更大的物质回报。</p><h3 id="2-永远不要敷衍工作"><a href="#2-永远不要敷衍工作" class="headerlink" title="2 永远不要敷衍工作"></a>2 永远不要敷衍工作</h3><p>永远不要敷衍工作，不要抱怨环境，不要埋怨别人，你可以反应，反应无效可以离开，暂时离不开可以折服，记住，一旦开始混日子，你混没的不仅仅是日子，一旦一开始讲是非，你就开始成为同事或者领导眼中的是非之人。</p><h3 id="3-事情做完马上汇报"><a href="#3-事情做完马上汇报" class="headerlink" title="3 事情做完马上汇报"></a>3 事情做完马上汇报</h3><p>事情做完马上汇报，千万不要让主管追着你问，事情如果做很久，阶段性的汇报工作进度，让别人知晓，如果工作出现失误或者不能如期完成，不要怕丢脸或被惩罚，要及时报告，等到出事再哭鼻子就晚了。</p><h3 id="4-管理好自己的情绪，做一个可爱的人"><a href="#4-管理好自己的情绪，做一个可爱的人" class="headerlink" title="4 管理好自己的情绪，做一个可爱的人"></a>4 管理好自己的情绪，做一个可爱的人</h3><p>没有人喜欢一个整天唉声叹气愁眉苦脸的家伙。不要把私人情绪带到公司，工作是工作，生活是生活，没有完美的公司，也没有不委屈的工作，做弹簧就不要做成橡皮泥，把压力变成动力。</p><h3 id="5-接受任务有确认机制"><a href="#5-接受任务有确认机制" class="headerlink" title="5 接受任务有确认机制"></a>5 接受任务有确认机制</h3><p>不清楚的任务要及时沟通，不要想当然，不要我以为，脑子走在手前面想清楚了再行动，不要糊里糊涂的开始，然后不停的纠错和反攻，错了就认，认了就改。切记被骂的最多的人总是那些不停找借口的人。</p><h3 id="6-注意工作汇报方式"><a href="#6-注意工作汇报方式" class="headerlink" title="6 注意工作汇报方式"></a>6 注意工作汇报方式</h3><p>老板不是法官，别成天怀里揣着公平公正公开，他们看的是利弊，不是对错，任何时候汇报工作要说结果，不要说过程，要说功劳不要说苦劳和疲劳，心疼你是老爸老妈或者男朋友女朋友该干的事，老板付了报酬，是为了看你们解决了问题或者创造了价值。</p><h3 id="7-注重细节"><a href="#7-注重细节" class="headerlink" title="7 注重细节"></a>7 注重细节</h3><p>迟到永远不是小事，你上班迟到见客户一定也会迟到，你做ppt有错别字，你写合同就难免不会出错，小事不小，细节决定成败，开会谈话时要带上一支笔，第一这是体现尊重，第二别太相信自己的记忆力，好记性不如烂笔头。</p><h3 id="8-提建议要有数据支撑"><a href="#8-提建议要有数据支撑" class="headerlink" title="8 提建议要有数据支撑"></a>8 提建议要有数据支撑</h3><p>当你提出建议时不要光说想法，而没有数据和依据的支撑。不要动不动就敲主管的门，“老大怎么办？…”</p><p>不要向你的主管问问题，或者给他判断题，要给他选择题。思考的过程才能给你带来成长，证明你的存在。</p><h3 id="9-要提升自己的价值"><a href="#9-要提升自己的价值" class="headerlink" title="9 要提升自己的价值"></a>9 要提升自己的价值</h3><p>不要被所谓的成功学所忽悠，什么圈子啊人脉啊…到处去社交什么用都没有，人脉的本质是资源对等的交换，不要错误的认为，你在一个微信群或者有对方的手机号，这些就是你的人脉了，经营人脉的前提是要提升自己的价值。</p><h3 id="10-认真对待工作汇报"><a href="#10-认真对待工作汇报" class="headerlink" title="10 认真对待工作汇报"></a>10 认真对待工作汇报</h3><p>不论是日报周报还是年度总结，这不是负担这是你表现自己的机会，不但学会干活，还要学会吆喝，对待主管兑现要大于承诺，答应的承诺要比要比约定的时间提早一点完成，或者在承诺的内容外多花一点心思，这是做好工作的基本要求，超出预期才有升职的可能。</p>]]></content>
    
    
    <categories>
      
      <category>社会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>职场经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解ThreadLocal</title>
    <link href="/2021/01/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/"/>
    <url>/2021/01/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h2><ul><li>每个线程需要一个独享的对象（通常时工具类，典型需要使用的类有SimpleDateFormat和Random）</li><li>每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。</li></ul><h3 id="场景一：每个线程需要一个独享对象"><a href="#场景一：每个线程需要一个独享对象" class="headerlink" title="场景一：每个线程需要一个独享对象"></a>场景一：每个线程需要一个独享对象</h3><p>每个Thread内有自己的实例副本，不共享</p><p>案例1，通过多线程并行执行打印1000次日期对象，并格式化为<code>yyyy-MM-dd hh:mm:ss</code></p><p>方法1： </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalTest01</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> finalI = i;<br>            threadPool.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    String date = <span class="hljs-keyword">new</span> ThreadLocalTest01().date(finalI);<br>                    System.out.println(date);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        threadPool.shutdown();<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-keyword">int</span> seconds)</span> </span>&#123;<br>        Date date = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">1000</span> * seconds);<br>        SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> dateFormat.format(date);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>从这个方法中我们可以看出，每次执行任务都需要创建一个SimpleDateFormat对象，这样我们相当于需要创建一千次SimpleDateFormat对象，造成一些没有必要的性能开销。</p><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalTest01</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">static</span> SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> finalI = i;<br>            threadPool.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    String date = <span class="hljs-keyword">new</span> ThreadLocalTest01().date(finalI);<br>                    System.out.println(date);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        threadPool.shutdown();<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-keyword">int</span> seconds)</span> </span>&#123;<br>        String format = <span class="hljs-keyword">null</span>;<br>        Date date = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">1000</span> * seconds);<br>        <span class="hljs-keyword">synchronized</span> (ThreadLocalTest01.class)&#123;<br>            format = dateFormat.format(date);<br>        &#125;<br>        <span class="hljs-keyword">return</span> format;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面这种方式虽然解决了对象反复创建带来的资源浪费问题，但是把对象抽离成共享静态变量难免产生线程安全问题，所以我们通过synchronized同步锁，让每一个线程排队等待，这样又产生了一个新的问题，就是同步等待带来的性能影响。所以我们需要通过ThreadLocal为每个线程单独开辟一个私有内存，使得每个线程都有一个属于自己的SimpleDateFormat对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalTest01</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> finalI = i;<br>            threadPool.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    String date = <span class="hljs-keyword">new</span> ThreadLocalTest01().date(finalI);<br>                    System.out.println(date);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        threadPool.shutdown();<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-keyword">int</span> seconds)</span> </span>&#123;<br>        String format = <span class="hljs-keyword">null</span>;<br>        Date date = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">1000</span> * seconds);<br>        SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal.get();<br>        <span class="hljs-keyword">return</span> dateFormat.format(date);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeFormatter</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt;<br>            dateFormatThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> SimpleDateFormat <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;<br><br>            <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="场景二：每个线程内需要保存全局变量"><a href="#场景二：每个线程内需要保存全局变量" class="headerlink" title="场景二：每个线程内需要保存全局变量"></a>场景二：每个线程内需要保存全局变量</h3><p>案例：当前用户信息需要被线程内所有方法共享</p><ul><li><p>一个比较繁琐的解决方法是把user作为参数层层传递，代码冗余且不易于维护</p><ul><li>在此基础上我们可以演进，使用Map，当发起请求，把用户信息存放到map当中，其他方法通过get获取。</li></ul><p>当多线程同时工作时，我们需要保证线程安全，可以用sychronized，也可以用ConcurrentHashMap，但无论用什么，都会对性能有所影响。</p></li><li><p>更好的办法是使用ThreadLocal，这样无需synchronized，可以在不影响性能的情况下，也无需层层传递参数，就可以保存当前线程对应的用户信息的目的。</p></li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalTest02</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Service1().process();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;小飞龙&quot;</span>);<br>        ThreadLocalUser.threadLocal.set(user);<br>        <span class="hljs-keyword">new</span> Service2().process();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        User user = ThreadLocalUser.threadLocal.get();<br>        System.out.println(<span class="hljs-string">&quot;Service2: &quot;</span>+user.name);<br>        <span class="hljs-keyword">new</span> Service3().process();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service3</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        User user = ThreadLocalUser.threadLocal.get();<br>        System.out.println(<span class="hljs-string">&quot;Service3: &quot;</span>+user.name);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalUser</span></span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  ThreadLocal&lt;User&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;User&gt;();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到Service2和Service3中都获取到了Service1中设置的属性</p><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101181928194.png" srcset="/img/loading.gif"><h3 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h3><ol><li>让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）</li><li>在任何方法中都可以轻松获取到该对象</li></ol><p><strong>我们可以根据共享对象的生成时机不同，选择initalValue或set来保存对象</strong></p><h4 id="场景一：-initialValue"><a href="#场景一：-initialValue" class="headerlink" title="场景一： initialValue"></a>场景一： initialValue</h4><blockquote><p>在ThreadLocal第一次get的时候把对象给初始化出来，对象的初始化时机可以由我们控制。</p></blockquote><h4 id="场景二：set"><a href="#场景二：set" class="headerlink" title="场景二：set"></a>场景二：set</h4><blockquote><p>如果需要保存到ThreadLocal里的对象生成时机不由我们随意控制，例如拦截器生成的用户信息。</p><p>用ThreadLocal.set()直接放到我们的ThreadLocal对象中去，以便后续使用。</p></blockquote><h4 id="使用ThreadLocal的好处"><a href="#使用ThreadLocal的好处" class="headerlink" title="使用ThreadLocal的好处"></a>使用ThreadLocal的好处</h4><ul><li>达到线程安全</li><li>不需要加锁，提高执行效率</li><li>更高效的利用内存、节省开销</li><li>免去传参的繁琐</li></ul><h3 id="ThreadLocal的主要方法"><a href="#ThreadLocal的主要方法" class="headerlink" title="ThreadLocal的主要方法"></a>ThreadLocal的主要方法</h3><p><strong>initialValue()</strong></p><ol><li><p>该方法会返回当前线程对应的”初始值”，这是一个延迟加载的方法，只有在调用get的时候才会触发。</p><p>源码分析：</p><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101184439498.png " srcset="/img/loading.gif"><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101184439498.png"><p>可以看到在调用get()方法时，最终返回setInitialValue();进一步跟踪到setInitialValue方法中</p><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101184514912.png " srcset="/img/loading.gif"><p>在这里我们可以看到返回的value 就是调用的 initalValue()方法。</p></li><li><p>当线程第一次调用get方法访问变量时，将调用此方法。</p></li><li><p>每个线程最多调用一次此方法，如果已经调用了remove()后，再调用get()，则可以再次调用此方法。</p></li><li><p>如果不重写本方法，这个方法会返回null。一般使用匿名内部类的方式来重写initialValue()方法。</p></li></ol><p>**set()**：为这个线程设置一个新值</p><p>**get()**：得到这个线程对应的value。如果是首次调用get()，则会调用initialize来得到这个值</p><p>**remove()**：删除对应的这个线程的值</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>进入到Thread类的源码里，我们可以看到一个ThreadLocalMap的属性</p><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101190832482.png " srcset="/img/loading.gif"><p>根据属性的名字就可以指导，这个ThreadLocalMap一定是用来存储多个ThreadLocal用的。</p><p>因为我们一个线程可能拥有多个ThreadLocal对象</p><p><strong>get方法</strong></p><ul><li><p>get方法是先取出当前线程的ThreadLocalMap</p><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101191533762.png" srcset="/img/loading.gif"></li><li><p>然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入。</p><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101191508310.png" srcset="/img/loading.gif"></li><li><p>取出map中属于ThreadLocal的value</p><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101191649253.png" srcset="/img/loading.gif"></li></ul><p><strong>initialValue方法</strong></p><ul><li>没有默认实现</li><li>如果 需要用initialValue方法，需要自己实现</li><li>通常使用匿名内部类的方式实现</li></ul><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101192024985.png"><p><strong>remove方法</strong></p><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101192105326.png"><ul><li>首先获取到当前线程，然后作为参数传到getMap里拿到对应的ThreadLocalMap，如果不为null，执行remove方法，当前threadLocal作为Key进行删除。</li></ul><h3 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h3><ul><li>ThreadLocalMap类，也就是Thread.threadLocals</li><li>ThreadLocalMap类是每个线程Thread里面的变量，里面最重要的是一个键值对数组Entry[] table，可以认为是一个map,键值对：<ul><li>键：这个ThreadLocal</li><li>值：实际需要的成员变量</li></ul></li><li>ThreadLocalMap处理哈希冲突是采用的线性探测法，也就是如果发生冲突，就继续寻找下一个空位置，而不是用链表拉链。</li></ul><h2 id="使用ThreadLocal的注意点"><a href="#使用ThreadLocal的注意点" class="headerlink" title="使用ThreadLocal的注意点"></a>使用ThreadLocal的注意点</h2><h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><p><strong>内存泄漏</strong> </p><blockquote><p>某个对象不再有用，但是占用内存却不能被回收</p></blockquote><img src="https://img.wclblog.top/images/深入理解ThreadLocal/image-20210101193741267.png" srcset="/img/loading.gif"><p>可以看出，在Entry中Thread是使用的弱引用，而每个value则是采用强引用。</p><p>弱引用特点： 若对象只被弱引用关联，那么这个对象就可以被回收</p><ul><li><p>ThreadLocalMap的每个Entry都是一个对Key的弱引用，同时每个Entry包含了一个对value的强引用</p></li><li><p>正常情况下，当线程终止，保存在ThreadLocal里的Value会被垃圾回收器回收，因为没有强引用了。</p></li><li><p>但是如果线程不终止（比如，线程保持很久）那么key对应的value就不能被回收，因为有以下调用链</p><p>Thread—&gt;ThreadLocalMap—&gt;Entry(key为null)—&gt;value</p><ul><li>因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能出现OOM</li><li>扫描key为null的Entry，并把value设置为null</li><li>如果一个ThreadLocal不被使用，就可能导致value的内存泄漏</li></ul></li></ul><p><strong>如何避免内存泄漏？（阿里规约）</strong></p><ul><li>调用remove方法，就会删除对应的Entry对象，可以避免内存泄漏，所以用完ThreadLocal之后就，应该调用remove方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>java基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池学习总结</title>
    <link href="/2021/01/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="线程池——治理线程的法宝"><a href="#线程池——治理线程的法宝" class="headerlink" title="线程池——治理线程的法宝"></a>线程池——治理线程的法宝</h2><p><strong>为什么要使用线程池？</strong></p><ul><li>反复创建线程开销大</li><li>过多的线程会占用太多内存</li></ul><p><strong>线程池的优点</strong></p><ul><li>加快相应速度</li><li>合理利用CPU和内存</li><li>统一管理</li></ul><p><strong>线程池适合的应用场合</strong></p><blockquote><p>服务器收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率</p></blockquote><h3 id="线程的增减时机"><a href="#线程的增减时机" class="headerlink" title="线程的增减时机"></a>线程的增减时机</h3><p><strong>线程池构造方法的参数</strong></p><table><thead><tr><th align="center">参数名</th><th align="center">类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">corePoolSize</td><td align="center">int</td><td align="center">核心线程数</td></tr><tr><td align="center">maxPoolSize</td><td align="center">int</td><td align="center">最大线程数</td></tr><tr><td align="center">keepAliveTime</td><td align="center">long</td><td align="center">保持存活时间</td></tr><tr><td align="center">workQueue</td><td align="center">BlockingQueue</td><td align="center">任务存储队列</td></tr><tr><td align="center">threadFactory</td><td align="center">ThreadFactory</td><td align="center">当线程池需要新的线程的时候，会使用threadFactory生成新的线程</td></tr><tr><td align="center">Handler</td><td align="center">RejectExcutionHandler</td><td align="center">由于线程池无法接受你所提交的任务的拒绝策略</td></tr></tbody></table><ul><li>corePoolSize指的是核心线程数<ul><li>线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新线程去执行任务</li></ul></li><li>maxPoolSize<ul><li>在核心线程数的基础上，额外增加的线程数的上限</li></ul></li></ul><p><strong>添加线程规则</strong></p><ol><li>如果线程数小于corePoolSize，创建一个新线程来运行新任务</li><li>如果线程数等于（或大于）corePoolSize但少于maxmumPoolSize，则将任务放入队列</li><li>如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程。</li></ol><ul><li>是否需要增加线程的判断顺序是：<ul><li>corePoolSize</li><li>workQueue</li><li>maxPoolSize</li></ul></li></ul><p><strong>增减线程的特点</strong></p><ol><li>通过设置corePoolSize和maxmumPoolSize相同，就可以创建固定大小的线程池</li><li>线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。</li><li>通过设置maxmumPoolSize为很高的值，可以允许线程池容纳任意数量的并发任务</li><li>只有在队列满时才创建多于corePoolSize的线程，如果使用的是无界队列，那么线程就不会超过corePoolSize</li></ol><h3 id="线程存活时间和工作队列"><a href="#线程存活时间和工作队列" class="headerlink" title="线程存活时间和工作队列"></a>线程存活时间和工作队列</h3><p><strong>keepAliveTime</strong></p><ul><li>如果线程池当前的线程数多于corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，他们就会被终止</li></ul><p><strong>ThreadFactory</strong>——用来创建线程</p><ul><li>默认使用Executors.defaultThreadFactory()</li><li>创建出来的线程都在同一个线程组</li><li>如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。</li></ul><p><strong>工作队列</strong></p><ul><li>3种最常见的队列类型<ul><li>直接交接：SynchronousQueue</li><li>无界队列：LinkedBlockingQueue</li><li>有界队列：ArrayBlockingQueue</li></ul></li></ul><h3 id="自动创建线程的风险"><a href="#自动创建线程的风险" class="headerlink" title="自动创建线程的风险"></a>自动创建线程的风险</h3><p><strong>线程池应该手动创建还是自动创建</strong></p><ul><li>手动创建更好，因为这样更加明确线程池的运行规则，避免资源耗尽的风险</li></ul><p><strong>常见的JDK提供的线程池</strong></p><ul><li>newFixedThreadPool ——定长线程池<ul><li>使用无界队列，容易造成队列内存过多，可能导致OOM</li></ul></li><li>newSingleThreadExecutor ——单线程任务线程池<ul><li>使用无界队列，当请求堆积的时候，可能会占用大量内存。</li></ul></li><li>newCachedThreadPool ——可缓存线程池<ul><li>弊端在于第二个参数maximumPoolSize被设置了Integer.MAX_VALUE，这可能会创建非常多的线程，甚至导致OOM</li></ul></li><li>newScheduledThreadPool ——支持定时及周期性任务执行的线程池</li></ul><p><strong>线程池应该手动创建还是自动创建</strong></p><ul><li>正确创建线程池的方法<ul><li>根据不同的业务场景，设置线程池参数</li><li>比如：内存有多大，给线程取什么名字等等</li></ul></li></ul><p><strong>线程池里的线程数量定为多少合适</strong></p><ul><li><p>CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。</p></li><li><p>耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数多倍。</p><p>参考Brain Goezt推荐的计算方法：</p><blockquote><p>线程数=CPU核心数*（1+平均等待时间/平均工作时间）</p></blockquote></li></ul><h3 id="对比各种线程池的特点"><a href="#对比各种线程池的特点" class="headerlink" title="对比各种线程池的特点"></a>对比各种线程池的特点</h3><table><thead><tr><th align="center">Parameter</th><th align="center">FixedThreadPool</th><th align="center">CachedThreadPool</th><th align="center">ScheduledThreadPool</th><th align="center">SingleThreaded</th></tr></thead><tbody><tr><td align="center">corePoolSize</td><td align="center">constructor-arg</td><td align="center">0</td><td align="center">constructor-arg</td><td align="center">1</td></tr><tr><td align="center">maxPoolSize</td><td align="center">same as corePoolSize</td><td align="center">Integer.MAX_VALUE</td><td align="center">Integer.MAX_VALUE</td><td align="center">1</td></tr><tr><td align="center">keepAliveTime</td><td align="center">0 seconds</td><td align="center">60 seconds</td><td align="center">0 seconds</td><td align="center">0 seconds</td></tr></tbody></table><h3 id="如何正确关闭线程池"><a href="#如何正确关闭线程池" class="headerlink" title="如何正确关闭线程池"></a>如何正确关闭线程池</h3><p><strong>关闭线程的方法</strong></p><ol><li>shutdown 当前线程执行完后，再次提交任务报错，但是无法立即停止当前线程。<ol><li>isShutdown 判断当前线程池是否调用了shutdown方法</li><li>isTerminated 判断线程池中线程是否完全清空和关闭</li></ol></li><li>shutdownNow 立刻关闭线程池，正在执行的线程收到interaputed信号，并返回队列中的任务集合。</li></ol><h3 id="暂停和恢复线程池"><a href="#暂停和恢复线程池" class="headerlink" title="暂停和恢复线程池"></a>暂停和恢复线程池</h3><p><strong>任务太多怎么拒绝？</strong></p><ul><li>拒绝时机<ul><li>当Executor关闭时，提交新任务会被拒绝</li><li>当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时</li></ul></li></ul><p><strong>4种拒绝策略</strong></p><ul><li>AbortPolicy</li><li>DiscardPolicy</li><li>DiscardOldestPolicy</li><li>CallerRunsPolicy</li></ul><h3 id="线程池实现原理和源码分析"><a href="#线程池实现原理和源码分析" class="headerlink" title="线程池实现原理和源码分析"></a>线程池实现原理和源码分析</h3><ul><li>线程池组成部分<ul><li>线程池管理器</li><li>工作线程</li><li>任务队列</li><li>任务接口（Task）</li></ul></li></ul><p><strong>Executor继承关系图</strong></p><img src="C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20210101144812273.png" alt="image-20210101144812273" style="zoom:33%;" /><p>Executor中只有一个方法，execute()用来执行任务的方法。</p><img src="C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20210101144938539.png" alt="image-20210101144938539" style="zoom:50%;" /><p>ExecutorService继承了Executor并新增了一些初步管理线程池的方法。</p><img src="C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20210101145311859.png" alt="image-20210101145311859" style="zoom:33%;" /><p><strong>线程池实现任务复用的原理</strong></p><p>executor()源码分析</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Proceed in 3 steps:</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="hljs-comment">         * start a new thread with the given command as its first</span><br><span class="hljs-comment">         * task.  The call to addWorker atomically checks runState and</span><br><span class="hljs-comment">         * workerCount, and so prevents false alarms that would add</span><br><span class="hljs-comment">         * threads when it shouldn&#x27;t, by returning false.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 2. If a task can be successfully queued, then we still need</span><br><span class="hljs-comment">         * to double-check whether we should have added a thread</span><br><span class="hljs-comment">         * (because existing ones died since last checking) or that</span><br><span class="hljs-comment">         * the pool shut down since entry into this method. So we</span><br><span class="hljs-comment">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="hljs-comment">         * stopped, or start a new thread if there are none.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="hljs-comment">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="hljs-comment">         * and so reject the task.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//如果当前线程数量小于核心线程数</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>            <span class="hljs-comment">//添加工作线程</span><br>            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>                <span class="hljs-keyword">return</span>;<br>            c = ctl.get();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>            <span class="hljs-keyword">int</span> recheck = ctl.get();<br>            <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>                reject(command);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>                addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>            reject(command);<br>    &#125;<br></code></pre></div></td></tr></table></figure><ol><li>首先判断当前线程数是否小于核心线程数，如果小于则添加worker，Worker就是主要工作的类，我们主要看一下runWorker() 在runWorker中主要实现了任务复用的逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>       Thread wt = Thread.currentThread();<br>    <span class="hljs-comment">//首先拿到一个任务</span><br>       Runnable task = w.firstTask;<br>       w.firstTask = <span class="hljs-keyword">null</span>;<br>       w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>       <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">//如果任务不为空</span><br>           <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>               w.lock();<br>               <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>               <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>               <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>               <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>               <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                    (Thread.interrupted() &amp;&amp;<br>                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                   !wt.isInterrupted())<br>                   wt.interrupt();<br>               <span class="hljs-keyword">try</span> &#123;<br>                   beforeExecute(wt, task);<br>                   Throwable thrown = <span class="hljs-keyword">null</span>;<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-comment">//调用run方法执行任务</span><br>                       task.run();<br>                   &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                       thrown = x; <span class="hljs-keyword">throw</span> x;<br>                   &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                       thrown = x; <span class="hljs-keyword">throw</span> x;<br>                   &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                       thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                   &#125; <span class="hljs-keyword">finally</span> &#123;<br>                       afterExecute(task, thrown);<br>                   &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                   task = <span class="hljs-keyword">null</span>;<br>                   w.completedTasks++;<br>                   w.unlock();<br>               &#125;<br>           &#125;<br>           completedAbruptly = <span class="hljs-keyword">false</span>;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           processWorkerExit(w, completedAbruptly);<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><p>我们可以看到任务的执行task.run()方法实在while循环当中的，我们获取下一个task并判断不为空，就会执行run方法，因此所有线程就可以去执行不同的任务。</p><h3 id="线程池状态和使用注意点"><a href="#线程池状态和使用注意点" class="headerlink" title="线程池状态和使用注意点"></a>线程池状态和使用注意点</h3><p><strong>线程池状态</strong></p><table><thead><tr><th align="center">状态</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">RUNNING</td><td align="center">接受新任务并处理排队任务</td></tr><tr><td align="center">SHUTDOWN</td><td align="center">不接受新任务，但处理排队任务</td></tr><tr><td align="center">STOP</td><td align="center">不接受新任务，也不处理排队任务，并中断正在执行的任务</td></tr><tr><td align="center">TIDYING</td><td align="center">所有任务都已终止，workerCount为零时，线程会转换到TIDYING，并将运行terminate()钩子方法</td></tr><tr><td align="center">TERMINATED</td><td align="center">terminate() 运行完成</td></tr></tbody></table><p><strong>使用线程注意点</strong></p><ul><li>避免任务堆积</li><li>避免线程数过度增加</li><li>排查线程泄露</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>java基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring源码品读</title>
    <link href="/2020/12/31/spring%E6%BA%90%E7%A0%81%E5%93%81%E8%AF%BB/"/>
    <url>/2020/12/31/spring%E6%BA%90%E7%A0%81%E5%93%81%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Spring核心接口和类"><a href="#Spring核心接口和类" class="headerlink" title="Spring核心接口和类"></a>Spring核心接口和类</h2><blockquote><p>spring框架解决了一个非常关键的问题，它可以让你将对象之间的关系转而用配置文件来进行管理</p></blockquote><ul><li>这便是它赖以生存的依赖注入机制，让对象之间的依赖关系在Spring的IoC容器中管理。</li><li>通过把对象包装在Bean中以达到管理对象和额外操作的目的</li></ul><h3 id="Bean与BeanDefinition"><a href="#Bean与BeanDefinition" class="headerlink" title="Bean与BeanDefinition"></a>Bean与BeanDefinition</h3><h4 id="Bean是Spring的一等公民"><a href="#Bean是Spring的一等公民" class="headerlink" title="Bean是Spring的一等公民"></a>Bean是Spring的一等公民</h4><ul><li><p>Bean的本质就是Java对象，只是这个对象的生命周期由容器来管理</p><p>用户可以根据自己的业务需求去定义一个java类，通过配置文件/配置类或者配置相关的注解等Spring框架能理解的方式告知Spring将该java类给管理起来，他就成为了Spring容器中的一个bean</p></li><li><p>不需要为了创建Bean而在原来的java类上添加任何额外的限制</p></li><li><p>对Java对象的控制方式体现在配置上</p></li></ul><h4 id="BeanDefinition-——Bean的定义"><a href="#BeanDefinition-——Bean的定义" class="headerlink" title="BeanDefinition ——Bean的定义"></a>BeanDefinition ——Bean的定义</h4><p><strong>根据配置，生成用来描述Bean的BeanDefinition</strong></p><p>常用属性：</p><ul><li>作用范围scope(@Scope)</li><li>懒加载lazy-init(@Lazy)：决定Bean实例是否延迟加载</li><li>首选primary(@Primary)：设置true的bean会是优先的实现类</li><li>factory-bean和factory-method(@Configuration和@Bean)</li></ul><h5 id="容器初始化主要做的事情"><a href="#容器初始化主要做的事情" class="headerlink" title="容器初始化主要做的事情"></a>容器初始化主要做的事情</h5><img src="https://img.wclblog.top/images/Spring源码品读/spring01.png" srcset="/img/loading.gif"><ul><li>解析配置</li><li>定位与注册对象</li></ul><p>在容器初始化或者bean实例首次使用的时候，容器会按照这些BeanIDifinition实例属性的指示将BeanDifinition对应的Bean实例创建出来，这主要取决于Bean的创建策略，是立即加载还是延迟加载。</p><h5 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h5><img src="https://img.wclblog.top/images/Spring源码品读/spring02.png" srcset="/img/loading.gif"><p>该接口实在spring-beans这个模块中，这个模块中存放的是spring简单容器相关的接口和类。</p><p>BeanDefinition继承了AttributeAccessor和BeanMetadataElement这两个接口，Spring中提供了大量的各种接口，每种接口都有不同的能力，某个类实现了某个接口也就相当于承诺拥有了某种能力。</p><p><strong>AttributeAccessor</strong></p><img src="https://img.wclblog.top/images/Spring源码品读/spring03.png" srcset="/img/loading.gif"><p>这个接口定义了最基本的对任意对象元数据的修改或者获取方式，用在BeanDefinition里主要就是用来获取BeanDefinition的属性，并对这些属性进行操作</p><p><strong>BeanMetadataElement</strong></p><img src="https://img.wclblog.top/images/Spring源码品读/spring04.png" srcset="/img/loading.gif"><p>这个接口提供了一个getSource方法，用来传输一个可配置的元对象，于BeanDefinition里来讲就是通过getSource方法返回BeanDefinition这个Class对象本身。</p><p>针对BeanDefinition来讲，主要向Spring容器描述了某个Bean的配置信息</p><img src="https://img.wclblog.top/images/Spring源码品读/spring04.png" srcset="/img/loading.gif"><p>像是否延迟加载isLazyInit();获取作用范围getScope()等等，在BeanDefinition都有相应的定义。</p><h5 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a>AbstractBeanDefinition</h5> <img src="https://img.wclblog.top/images/Spring源码品读/spring06.png" srcset="/img/loading.gif"><p>在BeanDefinition家族成员中有很多，我这里只列举一些比较常见的类</p><p>AbstractBeanDefinition是BeanDefinition实现类的基类</p><p>根据不同的使用场景，又分为了RootBeanDefinition,GenericBeanDefinition,ChildBeanDefinition</p><p>RootBeanDefinition: 可以单独作为一个BeanDefinition，也可以作为其他BeanDefinition的父类，但是不可以作为其他BeanDefinition的子类。</p> <img src="https://img.wclblog.top/images/Spring源码品读/Spring07.png" srcset="/img/loading.gif"><p>可以看到在setParentName方法里一旦设置parentName就会抛出异常。</p><p><strong>Spring里面定义的Bean之间的继承关系是通过在BeanDefinition设置parentName属性来决定的。</strong></p> <img src="https://img.wclblog.top/images/Spring源码品读/Spring08.png" srcset="/img/loading.gif"><p>从RootBeanDefinition源码介绍里可以看到RootBeanDefinition通常用于在运行时接收多个BeanDefinition合并起来的信息。一般情况下配置文件里的bean标签会被解析成RootBeanDefinition。</p><p>在Spring2.5之后，Spring引入了一个GenericBeanDefinition，将RootBeanDefinition和ChildBeanDefinition取代了。但是在合并属性的时候，还是会使用RootBeanDefinition来接收。</p><p>ChildBeanDefinition: 必须要依赖一个父的BeanDefinition不可以单独存在，不过已经被GenericBeanDefinition完全取代，不需要去学习。</p><h6 id="GenericBeanDefinition"><a href="#GenericBeanDefinition" class="headerlink" title="GenericBeanDefinition"></a>GenericBeanDefinition</h6><p>GenericBeanDefinition是Spring2.5以后新增加的Bean文件定义配置类，是RootBeanDefinition和ChildBeanDefinition更好的替代方案。</p><p>除了具有其他BeanDefinition的特征外，还具备了parentName属性，方便程序在运行时设定parentBeanDefinition</p><h3 id="SpringIoc容器"><a href="#SpringIoc容器" class="headerlink" title="SpringIoc容器"></a>SpringIoc容器</h3><blockquote><p>SpringIoc容器是一个管理Bean的容器，在Spring的定义中要求所有的容器都要实现接口BeanFactory</p></blockquote><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory位于org.springframework.beans.factory包下，是一个顶级的容器接口</p><p>在这个接口下，定义了一个<code>FACTORY_BEAN_PREFIX</code>的变量，该变量主要用于获取FactoryBean的实例</p><img src="https://img.wclblog.top/images/Spring源码品读/spring09.png" srcset="/img/loading.gif"><h5 id="BeanFacotry和FactoryBean-的区别？"><a href="#BeanFacotry和FactoryBean-的区别？" class="headerlink" title="BeanFacotry和FactoryBean 的区别？"></a>BeanFacotry和FactoryBean 的区别？</h5><p><strong>BeanFactory</strong></p><p>BeanFactory是Spring容器的根接口定义了Bean工厂的最基础的功能特性。比如：<code>Object getBean(String name) throws BeansException;</code>根据bean名字从容器中获取bean实例等等。</p><p>BeanFactory是一个管理Bean的容器，Spring生成的bean都是由BeanFactory的实现类来管理的。</p><p><strong>FactoryBean</strong></p><p>FactoryBean也是接口，根据<code>T getObject() throws Exception;</code>用户可以使用一套比较复杂的逻辑来生成Bean。</p><p>Factory本质也是一个Bean，但是这个bean不是用来注入到其他地方来使用的，而他的作用是用来生成一些普通的bean的，实现了这个接口之后，spring容器在初始化时，会把实现这个接口的Bean取出来，然后使用Bean里面的getObject方法来生成我们想要的Bean，当然那些生成Bean的业务逻辑也要写在getObject方法中。</p><h4 id="简单容器"><a href="#简单容器" class="headerlink" title="简单容器"></a>简单容器</h4><p>Spring的Ioc主要分为两个路线，一个是以BeanFactory为主的简单容器，一个是以ApplicationContext为主的高级容器。</p><p>ApplicationContext应用上下文高级容器也是我们广发使用的类型，相对于BeanFactory而言高级容器新增了很多面向实际应用的功能，让原本在BeanFactory中通过编码实现的功能简化到用配置即可完成。</p><h5 id="BeanFactory-1"><a href="#BeanFactory-1" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><img src="https://img.wclblog.top/images/Spring源码品读/spring10.png" srcset="/img/loading.gif"><p>根据程序设计的单一原则，其实每一个较顶层接口都是单一职责的，只提供某一方面的功能。</p><h6 id="ListableBeanFactory"><a href="#ListableBeanFactory" class="headerlink" title="ListableBeanFactory"></a>ListableBeanFactory</h6><blockquote><p>该接口的方法可以以列表的形式提供Bean的相关信息，这个接口最大的特点就是可以批量列出工厂生产的实例信息</p></blockquote><img src="https://img.wclblog.top/images/Spring源码品读/spring11.png" srcset="/img/loading.gif"><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取BeanDefinition总数</span><br>String[] getBeanDefinitionNames(); <span class="hljs-comment">//获取BeanDefinition名字的数组列表</span><br>String[] getBeanNamesForType(ResolvableType type);<span class="hljs-comment">//通过指定类型获取所有Bean名字</span><br><span class="hljs-comment">//....</span><br></code></pre></div></td></tr></table></figure><h6 id="AutowireCapableBeanFactory"><a href="#AutowireCapableBeanFactory" class="headerlink" title="AutowireCapableBeanFactory"></a>AutowireCapableBeanFactory</h6><blockquote><p>在spring中的@Autowired 自动装配的逻辑就是通过该接口的<code>Object resolveDependency()</code>方法来实现的依赖注入。</p></blockquote><p>在该接口中定义了五种装配策略</p><img src="https://img.wclblog.top/images/Spring源码品读/spring12.png" srcset="/img/loading.gif"><p>其中<code>AUTOWIRE_AUTODETECT</code>已经在Spring3.0中被废弃掉了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> AUTOWIRE_NO = <span class="hljs-number">0</span>; <span class="hljs-comment">//没有自动装配</span><br><span class="hljs-keyword">int</span> AUTOWIRE_BY_NAME = <span class="hljs-number">1</span>; <span class="hljs-comment">//根据名称自动装配</span><br><span class="hljs-keyword">int</span> AUTOWIRE_BY_TYPE = <span class="hljs-number">2</span>; <span class="hljs-comment">//根据类型自动装配</span><br><span class="hljs-keyword">int</span> AUTOWIRE_CONSTRUCTOR = <span class="hljs-number">3</span>; <span class="hljs-comment">//根据构造函数自动装配</span><br></code></pre></div></td></tr></table></figure><p>对于<code>@Autowired</code>标签来讲，其自动装配策略用的是<code>AUTOWIRE_BY_TYPE</code>根据类型自动装配</p><h4 id="高级容器"><a href="#高级容器" class="headerlink" title="高级容器"></a>高级容器</h4><div class="note note-success">            <p>Spring高级容器均实现了ApplicationContext这个接口</p><p>为了区别于简单容器，高级容器通常被称之为Context，即上下文。</p>          </div><blockquote><p>在我们使用SpringIoc容器的时候，与我们接触的绝大多数都是ApplicationContext接口的实现类。</p><p>BeanFactory是Spring的基础设施，面向Spring框架自身，而ApplicationContext面向的是使用Spring框架的开发者。</p></blockquote><img src="https://img.wclblog.top/images/Spring源码品读/spring13.png" srcset="/img/loading.gif"><p>进入到ApplicationContext，我们可以看到Application之所以被称为高级容器，是因为它比BeanFactory多了更多的功能，因为它继承了多个接口。</p><p><strong>首先我们看到它继承了EnvironmentCapable这个接口</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EnvironmentCapable</span> </span>&#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return the &#123;<span class="hljs-doctag">@link</span> Environment&#125; associated with this component.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Environment <span class="hljs-title">getEnvironment</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个接口里面我们看到只有一个<code>getEnvironment()</code>方法，该方法主要用来获取Environment。</p><p>说白了其实就是获取一些启动参数。</p><p><strong>此外，他还继承了ListableBeanFactory接口</strong></p><p>即可以通过列表的方式来管理Bean</p><p><strong>同时，还实现了HierarchicalBeanFactory接口</strong></p><p>即可以支持多层级的容器，来实现对每一层Bean的管理</p><p>除此之外，还继承了MessageSource, ApplicationEventPublisher, ResourcePatternResolver诸多接口</p><p><strong>ResourcePatternResolver</strong></p><p>这个接口可以用来加载资源文件的。</p><p><strong>MessageSource</strong></p><p>用来管理一些Message，实现国际化的功能</p><p><strong>ApplicationEventPublisher</strong></p><p>继承该接口，也就意味着ApplicationContext具备事件发布的能力</p><blockquote><p>ApplicationContext容器通过ApplicationEvent类和ApplicationListener接口进行事件处理，如果将实现ApplicationListener接口的Bean注册到容器中时，每次我们通过ApplicationContext发布的ApplicationEvent都会通知到注册的Listener中</p><p>这就是标准的观察者设计者模式</p></blockquote><h5 id="ApplicationContext常用容器"><a href="#ApplicationContext常用容器" class="headerlink" title="ApplicationContext常用容器"></a>ApplicationContext常用容器</h5><p>传统的基于XML配置的经典容器</p><ul><li>FileSystemXmlApplicationContext：从文件系统加载配置</li><li>ClassPathXmlApplicationContext：从classpath加载配置</li><li>XmlWebApplicationContext：用于Web应用程序的容器</li></ul><p>目前比较流行的容器</p><ul><li>AnnotationConfigServletWebServerApplicationContext</li><li>AnnotationConfigReactiveWebServerApplicationContext</li><li>AnnotationConfigApplicationContext</li></ul><div class="note note-info">            <p>他们都具备了refresh()的大致功能</p><ul><li>容器初始化、配置解析</li><li>BeanFactoryPostProcessor和BeanPostProcessor的注册和激活</li><li>国际化配置</li><li>…..</li></ul>          </div><img src="https://img.wclblog.top/images/Spring源码品读/spring14.png" srcset="/img/loading.gif"><p>回到ApplicationContext中，我们可以看到它里面的方法时只读的，也就是都是以get来打头的，即只提供get操作。 因此我们需要子接口来给Application提供可配置的能力，该接口便是<strong>ConfigrableApplicationContext</strong></p><img src="https://img.wclblog.top/images/Spring源码品读/spring15.png" srcset="/img/loading.gif"><p>它继承了Lifecycle接口，进入到这个接口中</p><img src="https://img.wclblog.top/images/Spring源码品读/spring16.png" srcset="/img/loading.gif"><blockquote><p>这个接口中提供了stop、start等方法，用于对生命周期的管理。</p></blockquote><p>同时继承了Closeable，这个接口时jdk提供的接口，用于容器关闭的时候释放相应的资源。</p><div class="note note-primary">            <p>ConfigrableApplicationContext 主要提供了refresh和close方法，具备启动刷新以及关闭应用上下文的能力，而这里的refresh方法，就是前面所提到的ApplicationContext主流实现容器都需要做的事情。</p><p>在ApplicationContext关闭的情况下，refresh可以重新启动容器</p><p>而在启动的情况下，调用refresh还可以清除缓存，并重新装载配置信息</p><p>具体的方法实现是在实现了该接口的AbstractApplicationContext抽象类中。</p>          </div><p><strong>AbstractApplicationContext</strong></p><blockquote><p>AbstractApplicationContext通过组合将众多容易变动的功能逻辑，代理给他的一些成员变量来实现，最后再使用模板方法模式，让子类为父类提供一些函数的支持或者设置替换上述的父类成员变量，从而实现了对扩展开放，对修改封闭的设计原则，也就是开闭原则。为SpringFramework提供了灵活性大，并且可扩展性强的架构支撑。</p></blockquote><p>其中的refresh方法便是模板方法模式最好的实现。</p><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><div class="note note-info">            <p>在java中，资源可以被抽象成URL，我们可以解析Url中的协议来处理不同资源的操作逻辑。</p><p>而Spring将对物理资源的访问方式，抽象成Resource</p>          </div><img src="https://img.wclblog.top/images/Spring源码品读/spring17.png" srcset="/img/loading.gif"><p>在该接口中定义了对资源的基本操作。Resource接口继承了InputStreamSource接口</p><p>InputStreamSource只提供了<code>getInputStream()</code>方法，该方法返回一个InputStream实例，即资源流。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>源码品读</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
